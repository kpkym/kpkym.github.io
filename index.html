<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>kpkym&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="个人学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="kpkym&#39;s blog">
<meta property="og:url" content="https://github.com/kpkym/index.html">
<meta property="og:site_name" content="kpkym&#39;s blog">
<meta property="og:description" content="个人学习笔记">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="kpkym&#39;s blog">
<meta name="twitter:description" content="个人学习笔记">
  
    <link rel="alternate" href="/atom.xml" title="kpkym&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">kpkym&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/kpkym"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-总结/RabbitMQ 总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/14/总结/RabbitMQ 总结/" class="article-date">
  <time datetime="2019-09-14T05:17:57.000Z" itemprop="datePublished">2019-09-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/中间件/">中间件</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/14/总结/RabbitMQ 总结/">RabbitMQ 总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>为什么要使用消息队列</p>
<ol>
<li>异步处理</li>
<li>系统解耦</li>
</ol>
<h1 id="1-一些概念梳理"><a href="#1-一些概念梳理" class="headerlink" title="1 一些概念梳理"></a>1 一些概念梳理</h1><ul>
<li>Server：又称为Broker。接收客户端连接，实现AMQP的服务器实体。</li>
<li>Connection：连接，应用程序与Broker的网络连接。</li>
<li>Channel：信道，几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道。客户端可建立多个Channel，每个Channel代表一个会话任务。</li>
<li>Message：消息。服务器和应用程序之间传递的数据，本质上就是一段数据，由Properties和Body组成。</li>
<li>Exchange：交换机。接收消息，根据路由键转发消息到绑定的队列。</li>
<li>Binding：Exchange和Queue之间的虚拟连接，binding中可以包含routing key。</li>
<li>Routing key：一个虚拟地址，虚拟机可用它来确定如何路由一个特定消息。</li>
<li>Queue：也称为Message Queue，消息队列，保存消息并将它们转发给消费者。</li>
<li>Virtual Host：其实是一个虚拟概念。类似于权限控制组，一个Virtual Host里面可以有若干个Exchange和Queue，可以用来隔离Exchange和Queue。，同一个Virtual Host里面不能有相同名称的Exchange和Queue。但是权限控制的最小粒度是Virtual Host。（下面会讲到）</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5225109-46b106ffc590da68.png?imageMogr2/auto-orient/strip|imageView2/2/w/1136/format/webp" alt></p>
<p>总结：</p>
<blockquote>
<p>生产者将消息发送到Exchange交换机的，不是发送到Queue上的，生产者不知道消息是谁消费，有哪些消费者消费。Exchange根据一定的路由规则将消息转发到Queue。<br>消费者是监听队列的，不知道是哪个生产者发送的。</p>
</blockquote>
<p>AMQP我的理解</p>
<blockquote>
<p>一个开放的面向消息中间件的协议，所有此协议的实现可以进行互相操作，无论实现语言如何，任何符合此协议的数据格式的消息工具都可以与任何其他兼容工具进行互操作。而以前JMS（Java Message Service），将不同的中间件的实现进行API层次的标准化。</p>
</blockquote>
<h1 id="2-四种类型Exchange"><a href="#2-四种类型Exchange" class="headerlink" title="2 四种类型Exchange"></a>2 四种类型Exchange</h1><p><img src="https://upload-images.jianshu.io/upload_images/5225109-84e0b04b2dac1efd.png?imageMogr2/auto-orient/strip|imageView2/2/w/1159/format/webp" alt><br>自己说说Exchange在RabbitMQ消息中间件中的作用：<br>服务器发送消息不会直接发送到队列中（Queue），而是直接发送给交换机（Exchange），然后根据确定的规则，RabbitMQ将会决定消息该投递到哪个队列。这些规则称为路由键（routing key），队列通过路由键绑定到交换机上。消息发送到服务器端（broker），消息也有自己的路由键（也可以是空），RabbitMQ也会将消息和消息指定发送的交换机的绑定（binding，就是队列和交互机的根据路由键映射的关系）的路由键进行匹配。如果匹配的话，就会将消息投递到相应的队列。</p>
<p>Exchange的类型主要有四种，分别是</p>
<ol>
<li>Direct Exchange：将消息中的Routing key与该Exchange关联的所有Binding中的Routing key进行比较，如果相等，则发送到该Binding对应的Queue中。</li>
<li>Topic Exchange：将消息中的Routing key与该Exchange关联的所有Binding中的Routing key进行对比，如果匹配上了，则发送到该Binding对应的Queue中。</li>
<li>Fanout Exchange：直接将消息转发到所有binding的对应queue中，这种exchange在路由转发的时候，忽略Routing key。</li>
<li>Headers Exchange：将消息中的headers与该Exchange相关联的所有Binging中的参数进行匹配，如果匹配上了，则发送到该Binding对应的Queue中。</li>
</ol>
<ul>
<li>Direct Exchange<blockquote>
<p>将消息中的Routing key与该Exchange关联的所有Binding中的Routing key进行比较，如果相等，则发送到该Binding对应的Queue中。<br>一个Exchange可以Binding一个或多个Queue。<br>绑定可以指定Routing key，Binding的多个Queue可以使用相同的Routing key，也可以使用不同的Routing key。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>特别的Exchange<br>默认的Exchange（名字为空，AMQP default）</p>
</blockquote>
<blockquote>
<p>默认的Exchange不能进行Binding操作<br>任何发送到该Exchange的消息都会被转发到Routing key指定的Queue中<br>如果vhost中不存在Routing key中指定的队列名，则该消息会被抛弃。</p>
</blockquote>
<ul>
<li>Topic Exchange<blockquote>
<p>将消息中的Routing key与该Exchange关联的所有Binding中的Routing key进行对比，如果匹配上了，则发送到该Binding对应的Queue中。</p>
<p>匹配规则<br>* 匹配一个单词<br># 匹配0个或多个字符<br>*，# 只能写在.号左右，且不能挨着字符<br>单词和单词之间需要用.隔开。</p>
</blockquote>
</li>
</ul>
<blockquote>
<blockquote>
<p>如果指定了Exchange是Topic类型的，但是相应的Binding中的Routing key *，#都没有，则相等才转发，类似于Direct Exchange<br>如果Binding中的Routing key为#或者#.#,则全部转发，类似Fanout Exchange</p>
</blockquote>
</blockquote>
<ul>
<li>Fanout Exchange<blockquote>
<p>直接将消息转发到所有binding的对应queue中，这种exchange在路由转发的时候，忽略Routing key。</p>
<blockquote>
<p>Fanout Exchange这种exchange效率最高，fanout &gt; direct &gt; topic</p>
</blockquote>
</blockquote>
</li>
</ul>
<p><strong>将消息中的headers与该Exchange相关联的所有Binging中的参数进行匹配，如果匹配上了，则发送到该Binding对应的Queue中。</strong></p>
<p>匹配规则：</p>
<ol>
<li>如果Binding中的</li>
<li>x-match = all：表示所有的键值对都匹配才能转发到消息。</li>
<li>x-match = any: 表示只要有键值对匹配就能转发消息。</li>
</ol>
<p>注意：</p>
<ol>
<li>Binging的时候，至少需要指定两个参数，其中的一个是x-match = all或x-match = any。</li>
<li>Binging的时候，不需要指定Routing key</li>
<li>发送消息的时候，不需要指定Routing key</li>
<li>转发消息的时候，忽略Routing key</li>
<li>如果是x-match = all则发送的headers不能比bingding的参数少，否则匹配不上。</li>
</ol>
<h1 id="3-Binding-Queue-Message概念"><a href="#3-Binding-Queue-Message概念" class="headerlink" title="3 Binding,Queue,Message概念"></a>3 Binding,Queue,Message概念</h1><p><strong>Binding</strong></p>
<ol>
<li>default Exchange不能进行Binding,也不需要进行绑定。</li>
<li>除default Exchange之外，其他任何Exchange都需要和Queue进行Binding，否则无法进行消息路由（转发）</li>
<li>Binding的时候，可以设置一个或多个参数，其中参数要特别注意参数类型，如果Routing key中指定的参数类型和消息中指定的参数类型不一致（header Exchange）也不能进行消息转发。</li>
<li>Direct Exchange，Topic Exchange进行Binding的时候，需要指定Routing key</li>
<li>Fanout Exchange，Headers Exchange进行Binding的时候，不需要指定Routing key。</li>
</ol>
<p><strong>Queue</strong></p>
<p>属性</p>
<ol>
<li>Durability：是否持久化，Durable是，Transient是否。如果不持久化，那么在服务器宕机或重启之后Queue就会丢失。</li>
<li>Auto delete：如果选择yes，当最后一个消费者不在监听Queue的时候，该Queue就会自动删除，一般选择false。</li>
<li>Arguments：AMQP协议留给AMQP实现者扩展使用的。<ol>
<li>x-message-ttl：一个消息推送到队列中的存活时间。设置的值之后还没消费就会被删除。</li>
<li>x-expires：在自动删除该队列的时候，可以使用该队列的时间。</li>
<li>x-max-length：在队列头部删除元素之前，队列可以包含多少个（就绪）消息，如果再次向队列中发送消息，会删除最早的那条消息，用来控制队列中消息的数量。</li>
<li>x-max-length-bytes：在队列头部删除元素之前，队列的总消息体的大小，用来控制队列中消息的总大小。</li>
<li>x-dead-letter-exchange：当消息被拒绝或者消息过期，消息重新发送到的交换机（Exchange）的可选名称。</li>
<li>x-dead-letter-routing-key：当消息被拒绝或者消息过期，消息重新发送到的交换机绑定的Route key的名称，如果没有设置则使用之前的Route key。</li>
<li>x-max-priority：队列支持的最大优先级数，如果没有设置则不支持消息优先级</li>
<li>x-queue-mode：将队列设置为延迟模式，在磁盘上保留尽可能多的消息以减少RAM使用; 如果未设置，队列将保持在内存中的缓存，以尽可能快地传递消息。</li>
<li>x-queue-master-locator：将队列设置为主位置模式，确定在节点集群上声明队列主节点所在的规则。</li>
</ol>
</li>
</ol>
<p><strong>Message概念</strong></p>
<p>消息。服务器和应用程序之间传送的数据，本质上就是一段数据，由Properties和Payload(body)组成。</p>
<ol>
<li>Delivery mode：是否持久化，如果未设置持久化，转发到queue中并未消费则重启服务或者服务宕机则消息丢失。</li>
<li>Headers：头信息，是由一个或多个健值对组成的，当固定的Properties不满足我们需要的时候，可以自己扩展。</li>
<li>Properties（属性）<ol>
<li>content_type：传输协议</li>
<li>content_encoding：编码方式</li>
<li>priority：优先级</li>
<li>correlation_id：rpc属性，请求的唯一标识。</li>
<li>reply_to：rpc属性，</li>
<li>expiration：消息的过期时间</li>
<li>message_id：消息的id</li>
<li>timestamp：消息的时间戳<br>…</li>
</ol>
</li>
</ol>
<p><strong>如何保证消息的不丢失，三个地方做到持久化。</strong></p>
<ul>
<li>Exchange需要持久化。</li>
<li>Queue需要持久化。</li>
<li>Message需要持久化。</li>
</ul>
<p><strong>通道和并发注意事项（线程安全）</strong></p>
<blockquote>
<p>根据经验，在线程间共享Channel（通道）是要避免的。应用应该优先使用每个线程自己的Channel（通道）实例，而不是多个线程共享这个Channel（通道）实例。</p>
</blockquote>
<blockquote>
<p>虽然有些在Channel（通道）上的操作是可以并发安全的调用，但是一些操作不行会导致一些边界交错，双重确认等等。</p>
</blockquote>
<blockquote>
<p>在共享（多线程）Channel（通道）上进行并发发布会导致一些边界交错，触发连接协议异常和连接关闭。因此需要严格在应用中同步调用（Channel#basicPublish必须在正确关键的地方调用）。线程之间的共享也会干扰生产者的消息确认。我们强烈的推荐不应该在通道上进行并发的发布消息。</p>
</blockquote>
<blockquote>
<p>在共享的Channel（通道）上一个线程生产（publish）消息，一个线程消费（consume）消息是线程安全的。</p>
</blockquote>
<blockquote>
<p>服务器推送可以同时发送，保证每通道的订阅被保留。 调度机制使用java.util.concurrent.ExecutorService。 可以使用单列的ConnectionFactory调用ConnectionFactory#setSharedExecutor去设置所有连接共用的executor。</p>
</blockquote>
<blockquote>
<p>当我们手动确认manual acknowledgements 的时候，很重要的是考虑什么线程去做这个ack确认。如果接收传递的线程（例如，Consumer＃handleDelivery委托给不同线程的传递处理）不同于手动确认的线程，则将多个线程参数设置为true是线程不安全的并导致双重确认，因此导致通道协议异常导致Channel关闭。一次确认一条消息可以确保安全的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过ConnectionFactory获得Connection，Connection得到Channel</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"192.168.1.131"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">"zhihao.miao"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line"></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建exchange，类型是direct类型</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">"zhihao.miao"</span>,<span class="string">"direct"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建exchange，类型是direct类型</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">"zhihao.miao.info"</span>, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三个参数表示是否持久化，同步操作，有返回值</span></span><br><span class="line">        AMQP.Exchange.DeclareOk ok = channel.exchangeDeclare(<span class="string">"zhihao.miao.debug"</span>,BuiltinExchangeType.DIRECT,<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(ok);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置属性</span></span><br><span class="line">        Map&lt;String,Object&gt; argument = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        argument.put(<span class="string">"alternate-exchange"</span>,<span class="string">"log"</span>);</span><br><span class="line">        channel.exchangeDeclare(<span class="string">"zhihao.miao.warn"</span>,BuiltinExchangeType.TOPIC,<span class="keyword">true</span>,<span class="keyword">false</span>,argument);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//异步创建exchange，没有返回值</span></span><br><span class="line">        channel.exchangeDeclareNoWait(<span class="string">"zhihao.miao.log"</span>,BuiltinExchangeType.TOPIC,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,argument);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断exchange是否存在,存在的返回ok，不存在的exchange则报错</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        AMQP.Exchange.DeclareOk declareOk = channel.exchangeDeclarePassive("zhihao.miao.info");</span></span><br><span class="line"><span class="comment">        System.out.println(declareOk);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        declareOk = channel.exchangeDeclarePassive("zhihao.miao.info2");</span></span><br><span class="line"><span class="comment">        System.out.println(declareOk);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除exchange(可重复执行），删除一个不存在的也不会报错</span></span><br><span class="line">        channel.exchangeDelete(<span class="string">"zhihao.miao"</span>);</span><br><span class="line">        channel.exchangeDelete(<span class="string">"zhihao.miao.debug"</span>);</span><br><span class="line">        channel.exchangeDelete(<span class="string">"zhihao.miao.info"</span>);</span><br><span class="line">        channel.exchangeDelete(<span class="string">"zhihao.miao.warn"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除exchange</span></span><br><span class="line">        channel.exchangeDelete(<span class="string">"zhihao.miao.log"</span>);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列的api操作。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"192.168.1.131"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">"zhihao.miao"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line"></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二个参数表示是否持久化，第三个参数是判断这个队列是否在连接是否生效，为true表示连接关闭队列删除。</span></span><br><span class="line">        AMQP.Queue.DeclareOk ok = channel.queueDeclare(<span class="string">"zhihao.info"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(ok);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//异步没有返回值的方法api</span></span><br><span class="line">        channel.queueDeclareNoWait(<span class="string">"zhihao.info.miao"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断queue是否存在，不存在会抛出异常</span></span><br><span class="line">        <span class="comment">//channel.exchangeDeclarePassive("zhihao.info");</span></span><br><span class="line">        <span class="comment">//抛出错误</span></span><br><span class="line">        <span class="comment">//channel.exchangeDeclarePassive("zhihao.info.miao2");</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//exchange和queue进行绑定（可重复执行，不会重复创建）</span></span><br><span class="line">        channel.queueBind(<span class="string">"zhihao.info"</span>,<span class="string">"zhihao.miao.order"</span>,<span class="string">"info"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//异步进行绑定</span></span><br><span class="line">        channel.queueBindNoWait(<span class="string">"zhihao.info.miao"</span>,<span class="string">"zhihao.miao.pay"</span>,<span class="string">"info"</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//exchange与exchange进行绑定(可重复执行，不会重复创建）</span></span><br><span class="line">        channel.exchangeBind(<span class="string">"zhihao.miao.email"</span>,<span class="string">"zhihao.miao.weixin"</span>,<span class="string">"debug"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//exchange和queue进行解绑（可重复执行）</span></span><br><span class="line">        channel.queueUnbind(<span class="string">"zhihao.info"</span>,<span class="string">"zhihao.miao.order"</span>,<span class="string">"info"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//exchange和exchange进行解绑（可重复执行）</span></span><br><span class="line">        channel.exchangeUnbind(<span class="string">"zhihao.info.miao"</span>,<span class="string">"zhihao.miao.pay"</span>,<span class="string">"debug"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除队列</span></span><br><span class="line">        channel.queueDelete(<span class="string">"zhihao.info"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息的发送：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setUri(<span class="string">"amqp://zhihao.miao:123456@192.168.1.131:5672"</span>);</span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line"></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder().deliveryMode(<span class="number">2</span>).</span><br><span class="line">                contentEncoding(<span class="string">"UTF-8"</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个参数是exchange参数，如果是为空字符串，那么就会发送到(AMQP default)默认的exchange，而且routingKey</span></span><br><span class="line">        <span class="comment">//便是所要发送到的队列名</span></span><br><span class="line">        channel.basicPublish(<span class="string">""</span>,<span class="string">"zhihao.info.miao"</span>,properties,<span class="string">"忘记密码，验证码是1234"</span>.getBytes());</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>,<span class="string">"zhihao.miao"</span>,properties,<span class="string">"忘记密码，六位验证密码是343sdf"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//direct类型的exchange类型的exchange，zhihao.miao.order绑定zhihao.info.miao队列，route key是order</span></span><br><span class="line">        channel.basicPublish(<span class="string">"zhihao.miao.order"</span>,<span class="string">"order"</span>,properties,<span class="string">"爱奇艺会员到期了"</span>.getBytes());</span><br><span class="line">        <span class="comment">//zhihao.miao.pay绑定zhihao.info.miao队列，route key是order</span></span><br><span class="line">        channel.basicPublish(<span class="string">"zhihao.miao.pay"</span>,<span class="string">"pay"</span>,properties,<span class="string">"优酷会员到期了"</span>.getBytes());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//topic类型的exchange</span></span><br><span class="line">        channel.basicPublish(<span class="string">"log"</span>,<span class="string">"user.log"</span>,properties,<span class="string">"你的外卖已经送达"</span>.getBytes());</span><br><span class="line">        channel.basicPublish(<span class="string">"log"</span>,<span class="string">"user.log.info"</span>,properties,<span class="string">"你的外卖正在配送中"</span>.getBytes());</span><br><span class="line">        channel.basicPublish(<span class="string">"log"</span>,<span class="string">"user"</span>,properties,<span class="string">"你的投诉已经采纳"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息消费：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"192.168.1.131"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">"zhihao.miao"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户端的消费消息</span></span><br><span class="line">        Map&lt;String,Object&gt; clientProperties = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        clientProperties.put(<span class="string">"desc"</span>,<span class="string">"支付系统2.0"</span>);</span><br><span class="line">        clientProperties.put(<span class="string">"author"</span>,<span class="string">"zhihao.miao"</span>);</span><br><span class="line">        clientProperties.put(<span class="string">"user"</span>,<span class="string">"zhihao.miao@xxx.com"</span>);</span><br><span class="line"></span><br><span class="line">        connectionFactory.setClientProperties(clientProperties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给客户端的connetction命名</span></span><br><span class="line">        Connection connection = connectionFactory.newConnection(<span class="string">"log队列的消费者"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给channel起个编号</span></span><br><span class="line">        Channel channel = connection.createChannel(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回consumerTag，也可以通过重载方法进行设置consumerTag</span></span><br><span class="line">        String consumerTag = channel.basicConsume(<span class="string">"user_log_queue"</span>,<span class="keyword">true</span>,<span class="keyword">new</span> SimpleConsumer(channel));</span><br><span class="line">        System.out.println(consumerTag);</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的消息逻辑，继承DefaultConsumer类重写handleDelivery方法，如果是手工确认消息，会在handleDelivery方法中进行相关的确认（调用相关api）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleConsumer</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleConsumer</span><span class="params">(Channel channel)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(consumerTag);</span><br><span class="line">        System.out.println(<span class="string">"-----收到消息了---------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"消息属性为："</span>+properties);</span><br><span class="line">        System.out.println(<span class="string">"消息内容为："</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-Spring-AMQP简介与quick-start"><a href="#4-Spring-AMQP简介与quick-start" class="headerlink" title="4 Spring AMQP简介与quick start"></a>4 Spring AMQP简介与quick start</h1><p>Spring AMQP包括两个部分；spring-amqp是对amqp的一些概念的一些抽象。spring-rabbit是对AMQP的实现RabbitMQ的实现。</p>
<p>特征</p>
<ol>
<li>异步处理消费消息的一个监听容器（Listener container）</li>
<li>使用RabbitTemplate类的实例来发送和接收消息。</li>
<li>使用RabbitAdmin去自动声明队列（queues），交换机（exchanges），绑定（bindings）</li>
<li>spring-amqp模块是对AMQP协议的一个抽象和封装。所以说对所有的AMQP的实现都进行的抽象和封装，比如<br>org.springframework.amqp.core.Binding：绑定的封装，类型有QUEUE和EXCHANGE。<br>org.springframework.amqp.core.Exchange：其有基本的四种实现</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一次性生成多个queue，exchange,binding</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeclareConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Queue&gt; <span class="title">queues</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Queue&gt; queueList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        queueList.add(<span class="keyword">new</span> Queue(<span class="string">"chao.wang.debug"</span>,<span class="keyword">true</span>));</span><br><span class="line">        queueList.add(<span class="keyword">new</span> Queue(<span class="string">"chao.wang.info"</span>,<span class="keyword">true</span>));</span><br><span class="line">        queueList.add(<span class="keyword">new</span> Queue(<span class="string">"chao.wang.error"</span>,<span class="keyword">true</span>));</span><br><span class="line">        <span class="keyword">return</span> queueList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Exchange&gt; <span class="title">exchanges</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Exchange&gt; exchangeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        exchangeList.add(<span class="keyword">new</span> TopicExchange(<span class="string">"chao.wang.debug.topic.exchange"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>));</span><br><span class="line">        exchangeList.add(<span class="keyword">new</span> TopicExchange(<span class="string">"chao.wang.info.topic.exchange"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>));</span><br><span class="line">        exchangeList.add(<span class="keyword">new</span> TopicExchange(<span class="string">"chao.wang.error.topic.exchange"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>));</span><br><span class="line">        <span class="keyword">return</span> exchangeList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Binding&gt; <span class="title">bindings</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Binding&gt; bindingList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        bindingList.add(BindingBuilder.bind(<span class="keyword">new</span> Queue(<span class="string">"chao.wang.debug"</span>)).</span><br><span class="line">                to(<span class="keyword">new</span> TopicExchange(<span class="string">"chao.wang.debug.topic.exchange"</span>)).with(<span class="string">"chao.wang.#"</span>));</span><br><span class="line">        bindingList.add(BindingBuilder.bind(<span class="keyword">new</span> Queue(<span class="string">"chao.wang.info"</span>)).</span><br><span class="line">                to(<span class="keyword">new</span> TopicExchange(<span class="string">"chao.wang.debug.topic.exchange"</span>)).with(<span class="string">"chao.wang.*"</span>));</span><br><span class="line">        bindingList.add(BindingBuilder.bind(<span class="keyword">new</span> Queue(<span class="string">"chao.wang.error"</span>)).</span><br><span class="line">                to(<span class="keyword">new</span> TopicExchange(<span class="string">"chao.wang.debug.topic.exchange"</span>)).with(<span class="string">"chao.wang.error.*"</span>));</span><br><span class="line">        <span class="keyword">return</span> bindingList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自动声明的一些条件</p>
<ul>
<li>要有连接（对rabbitmq的连接）</li>
<li>容器中要有org.springframework.amqp.rabbit.core.RabbitAdmin的实例</li>
<li>RabbitAdmin的autoStartup属性必须为true。</li>
<li>如果ConnectionFactory使用的是CachingConnectionFactory，则cacheMode必须是CachingConnectionFactory.CacheMode.CHANNEL（默认）。</li>
<li>所要声明的组件(Queue，Exchange和Binding)的shouldDeclare必须是true（默认就是true）</li>
<li>Queue队列的名字不能以amq.开头。<blockquote>
<p>注意：Queue，Exchange和Binding都直接或者间接的继承Declarable，而Declarable中定义了shouldDeclare的方法。</p>
</blockquote>
</li>
</ul>
<p>SimpleMessageListenerContainer更多用法 <a href="https://www.jianshu.com/p/213827ebc08c" target="_blank" rel="noopener">SimpleMessageListenerContainer更多用法</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">messageListenerContainer</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">        SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">        container.setConnectionFactory(connectionFactory);</span><br><span class="line">        container.setQueueNames(<span class="string">"order"</span>,<span class="string">"pay"</span>,<span class="string">"zhihao.miao.order"</span>);</span><br><span class="line"></span><br><span class="line">        MessageListenerAdapter adapter = <span class="keyword">new</span> MessageListenerAdapter(<span class="keyword">new</span> MessageHandler());</span><br><span class="line">        <span class="comment">//设置处理器的消费消息的默认方法,如果没有设置，那么默认的处理器中的默认方式是handleMessage方法</span></span><br><span class="line">        adapter.setDefaultListenerMethod(<span class="string">"onMessage"</span>);</span><br><span class="line">        Map&lt;String, String&gt; queueOrTagToMethodName = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        queueOrTagToMethodName.put(<span class="string">"order"</span>,<span class="string">"onorder"</span>);</span><br><span class="line">        queueOrTagToMethodName.put(<span class="string">"pay"</span>,<span class="string">"onpay"</span>);</span><br><span class="line">        queueOrTagToMethodName.put(<span class="string">"zhihao.miao.order"</span>,<span class="string">"oninfo"</span>);</span><br><span class="line">        adapter.setQueueOrTagToMethodName(queueOrTagToMethodName);</span><br><span class="line">        container.setMessageListener(adapter);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MessageListenerAdapter</span></span><br><span class="line"><span class="comment">// 1.可以把一个没有实现MessageListener和ChannelAwareMessageListener接口的类适配成一个可以处理消息的处理器</span></span><br><span class="line"><span class="comment">// 2.默认的方法名称为：handleMessage，可以通过setDefaultListenerMethod设置新的消息处理方法</span></span><br><span class="line"><span class="comment">// 3.MessageListenerAdapter支持不同的队列交给不同的方法去执行。使用setQueueOrTagToMethodName方法设置，当根据queue名称没有找到匹配的方法的时候，就会交给默认的方法去处理。</span></span><br></pre></td></tr></table></figure>
<p>MessageConverter</p>
<p>源码分析总结：</p>
<ol>
<li>MessageConverter可以把java对象转换成Message对象，也可以把Message对象转换成java对象</li>
<li>MessageListenerAdapter内部通过MessageConverter把Message转换成java对象，然后找到相应的处理方法，参数为转换成的java对象。</li>
<li>SimpleMessageConverter处理逻辑：<ol>
<li>如果content_type是以text开头，则把消息转换成String类型</li>
<li>如果content_type的值是application/x-java-serialized-object则把消息序列化为java对象，否则，把消息转换成字节数组。</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendOrder</span><span class="params">( RabbitTemplate rabbitTemplate)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        order.setId(<span class="number">1</span>);</span><br><span class="line">        order.setUserId(<span class="number">1000</span>);</span><br><span class="line">        order.setAmout(<span class="number">88</span>d);</span><br><span class="line">        order.setTime(LocalDateTime.now().toString());</span><br><span class="line"></span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        String json = mapper.writeValueAsString(order);</span><br><span class="line">        System.out.println(json);</span><br><span class="line"></span><br><span class="line">        MessageProperties messageProperties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">        messageProperties.setContentType(<span class="string">"application/json"</span>);</span><br><span class="line">        <span class="comment">//指定的__TypeId__属性值必须是消费端的Order的全类名，如果不匹配则会报错。</span></span><br><span class="line">        messageProperties.getHeaders().put(<span class="string">"__TypeId__"</span>,<span class="string">"com.zhihao.miao.test.day10.Sender.Order"</span>);</span><br><span class="line">        Message message = <span class="keyword">new</span> Message(json.getBytes(),messageProperties);</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.send(<span class="string">""</span>,<span class="string">"zhihao.miao.order"</span>,message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(Application.class);</span><br><span class="line">        RabbitTemplate rabbitTemplate = context.getBean(RabbitTemplate.class);</span><br><span class="line">        System.out.println(rabbitTemplate);</span><br><span class="line">        sendOrder(rabbitTemplate);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================================================================================================</span></span><br><span class="line"><span class="comment">// 在jackson2JsonMessageConverter转换器中指定映射配置</span></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">messageListenerContainer</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">        SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">        container.setConnectionFactory(connectionFactory);</span><br><span class="line">        container.setQueueNames(<span class="string">"zhihao.miao.order"</span>);</span><br><span class="line"></span><br><span class="line">        MessageListenerAdapter adapter = <span class="keyword">new</span> MessageListenerAdapter(<span class="keyword">new</span> MessageHandler());</span><br><span class="line">        <span class="comment">//指定Json转换器</span></span><br><span class="line">        Jackson2JsonMessageConverter jackson2JsonMessageConverter =<span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费端配置映射</span></span><br><span class="line">        Map&lt;String, Class&lt;?&gt;&gt; idClassMapping = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        idClassMapping.put(<span class="string">"order"</span>,Order.class);</span><br><span class="line">        idClassMapping.put(<span class="string">"user"</span>,User.class);</span><br><span class="line"></span><br><span class="line">        DefaultJackson2JavaTypeMapper jackson2JavaTypeMapper = <span class="keyword">new</span> DefaultJackson2JavaTypeMapper();</span><br><span class="line">        jackson2JavaTypeMapper.setIdClassMapping(idClassMapping);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"在jackson2JsonMessageConverter转换器中指定映射配置"</span>);</span><br><span class="line">        jackson2JsonMessageConverter.setJavaTypeMapper(jackson2JavaTypeMapper);</span><br><span class="line">        adapter.setMessageConverter(jackson2JsonMessageConverter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置处理器的消费消息的默认方法</span></span><br><span class="line">        adapter.setDefaultListenerMethod(<span class="string">"onMessage"</span>);</span><br><span class="line">        container.setMessageListener(adapter);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后在生产端就可以指定对应的key，而不需要再去指定全类名了，</span></span><br><span class="line">MessageProperties messageProperties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">messageProperties.setContentType(<span class="string">"application/json"</span>);</span><br><span class="line">messageProperties.getHeaders().put(<span class="string">"__TypeId__"</span>,<span class="string">"order"</span>);</span><br><span class="line">Message message = <span class="keyword">new</span> Message(json.getBytes(),messageProperties);</span><br><span class="line"></span><br><span class="line"><span class="comment">// List</span></span><br><span class="line">MessageProperties messageProperties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">messageProperties.setContentType(<span class="string">"application/json"</span>);</span><br><span class="line">messageProperties.getHeaders().put(<span class="string">"__TypeId__"</span>,<span class="string">"java.util.List"</span>);</span><br><span class="line">messageProperties.getHeaders().put(<span class="string">"__ContentTypeId__"</span>,<span class="string">"order"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line">MessageProperties messageProperties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">messageProperties.setContentType(<span class="string">"application/json"</span>);</span><br><span class="line">messageProperties.getHeaders().put(<span class="string">"__TypeId__"</span>,<span class="string">"java.util.Map"</span>);</span><br><span class="line">messageProperties.getHeaders().put(<span class="string">"__KeyTypeId__"</span>,<span class="string">"java.lang.String"</span>);</span><br><span class="line">messageProperties.getHeaders().put(<span class="string">"__ContentTypeId__"</span>,<span class="string">"order"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// public void onMessage(List&lt;Order&gt; orders)&#123;</span></span><br><span class="line"><span class="comment">//     System.out.println("---------onMessage---List&lt;Order&gt;-------------");</span></span><br><span class="line"><span class="comment">//     orders.stream().forEach(order -&gt; System.out.println(order));</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// public void onMessage(Map&lt;String,Object&gt; orderMaps)&#123;</span></span><br><span class="line"><span class="comment">//     System.out.println("-------onMessage---Map&lt;String,Object&gt;------------");</span></span><br><span class="line"><span class="comment">//     orderMaps.keySet().forEach(key -&gt; System.out.println(orderMaps.get(key)));</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>结论</strong></p>
<blockquote>
<p>如果生产者发送的是list的json数据，则还需要增加一个<strong>ContentTypeId</strong>的header，用于指明List里面的具体对象。</p>
</blockquote>
<blockquote>
<p>如果生产者发送的是map的json数据，则需要指定<strong>KeyTypeId</strong>，<strong>ContentTypeId</strong>的header，用于指明map里面的key，value的具体对象。</p>
</blockquote>
<blockquote>
<p>ContentTypeDelegatingMessageConverter详解</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// MessageProperties messageProperties = new MessageProperties();</span></span><br><span class="line"><span class="comment">// messageProperties.setContentType("text/plain");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MessageProperties messageProperties = new MessageProperties();</span></span><br><span class="line"><span class="comment">// messageProperties.setContentType("image/jepg");</span></span><br><span class="line"></span><br><span class="line">TextMessageConverter textMessageConverter = <span class="keyword">new</span> TextMessageConverter();</span><br><span class="line"></span><br><span class="line">ContentTypeDelegatingMessageConverter contentTypeDelegatingMessageConverter = <span class="keyword">new</span> ContentTypeDelegatingMessageConverter();</span><br><span class="line">contentTypeDelegatingMessageConverter.addDelegate(<span class="string">"text"</span>,textMessageConverter);</span><br><span class="line">contentTypeDelegatingMessageConverter.addDelegate(<span class="string">"html/text"</span>,textMessageConverter);</span><br><span class="line">contentTypeDelegatingMessageConverter.addDelegate(<span class="string">"xml/text"</span>,textMessageConverter);</span><br><span class="line">contentTypeDelegatingMessageConverter.addDelegate(<span class="string">"text/plain"</span>,textMessageConverter);</span><br><span class="line"></span><br><span class="line">contentTypeDelegatingMessageConverter.addDelegate(<span class="string">"json"</span>,jackson2JsonMessageConverter);</span><br><span class="line">contentTypeDelegatingMessageConverter.addDelegate(<span class="string">"application/json"</span>,jackson2JsonMessageConverter);</span><br><span class="line"></span><br><span class="line">contentTypeDelegatingMessageConverter.addDelegate(<span class="string">"image/jpg"</span>,<span class="keyword">new</span> JPGMessageConverter());</span><br><span class="line">contentTypeDelegatingMessageConverter.addDelegate(<span class="string">"image/jepg"</span>,<span class="keyword">new</span> JPGMessageConverter());</span><br><span class="line">contentTypeDelegatingMessageConverter.addDelegate(<span class="string">"image/png"</span>,<span class="keyword">new</span> JPGMessageConverter());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">adapter.setMessageConverter(contentTypeDelegatingMessageConverter);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结论：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ContentTypeDelegatingMessageConverter是一个代理的MessageConverter。</span></span><br><span class="line"><span class="comment">// ContentTypeDelegatingMessageConverter本身不做消息转换的具体动作，而是将消息转换委托给具体的MessageConverter。我们可以设置COntentType和MessageConverter的映射关系。</span></span><br><span class="line"><span class="comment">// ContentTypeDelegatingMessageConverter还有一个默认的MessageConverter，也就是说当根据ContentType没有找到映射的MessageConverter的时候，就会使用默认的MessageConverter。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RabbitListenerConfigurer</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">connectionFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CachingConnectionFactory factory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">        factory.setUri(<span class="string">"amqp://zhihao.miao:123456@192.168.1.131:5672"</span>);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RabbitListenerContainerFactory&lt;?&gt; rabbitListenerContainerFactory(ConnectionFactory connectionFactory)&#123;</span><br><span class="line">        SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">        factory.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RabbitListenerConfigurer <span class="title">rabbitListenerConfigurer</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RabbitListenerConfigurer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureRabbitListeners</span><span class="params">(RabbitListenerEndpointRegistrar registrar)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//endpoint设置zhihao.miao.order队列的消息处理逻辑</span></span><br><span class="line">                SimpleRabbitListenerEndpoint endpoint = <span class="keyword">new</span> SimpleRabbitListenerEndpoint();</span><br><span class="line">                endpoint.setId(<span class="string">"10"</span>);</span><br><span class="line">                endpoint.setQueueNames(<span class="string">"zhihao.miao.order"</span>);</span><br><span class="line">                endpoint.setMessageListener(message -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">"endpoint1处理消息的逻辑"</span>);</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">//使用适配器来处理消息，设置了order，pay队列的消息处理逻辑</span></span><br><span class="line">                SimpleRabbitListenerEndpoint endpoint2 = <span class="keyword">new</span> SimpleRabbitListenerEndpoint();</span><br><span class="line">                endpoint2.setId(<span class="string">"11"</span>);</span><br><span class="line">                endpoint2.setQueueNames(<span class="string">"order"</span>,<span class="string">"pay"</span>);</span><br><span class="line">                System.out.println(<span class="string">"endpoint2处理消息的逻辑"</span>);</span><br><span class="line">                endpoint2.setMessageListener(<span class="keyword">new</span> MessageListenerAdapter(<span class="keyword">new</span> MessageHandler()));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//注册二个endpoint</span></span><br><span class="line">                registrar.registerEndpoint(endpoint);</span><br><span class="line">                registrar.registerEndpoint(endpoint2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<blockquote>
<p>如果消息属性中没有指定content_type，则接收消息的处理方法接收类型是byte[],如果消息属性中指定content_type为text，则接收消息的处理方法的参数类型是String类型。不管有没有指定content_type，处理消息方法的参数类型是Message都不会报错。</p>
</blockquote>
<p><strong>使用@RabbitListener注解消费消息</strong></p>
<p>在启动入口增加@EnableRabbit注解<br>在spring容器中托管一个RabbitListenerContainerFactory的bean（默认的实现是org.springframework.amqp.rabbit.config.SimpleRabbitListenerContainerFactory）<br>写一个消息处理类托管到spring容器中，然后在具体的消息处理方法上增加@RabbitListener注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//支持自动声明绑定，声明之后自动监听队列的队列，此时@RabbitListener注解的queue和bindings不能同时指定，否则报错</span></span><br><span class="line">    <span class="meta">@RabbitListener</span>(bindings =&#123;<span class="meta">@QueueBinding</span>(value = <span class="meta">@Queue</span>(value = <span class="string">"q5"</span>,durable = <span class="string">"true"</span>),</span><br><span class="line">            exchange =<span class="meta">@Exchange</span>(value = <span class="string">"zhihao.miao.exchange"</span>,durable = <span class="string">"true"</span>),key = <span class="string">"welcome"</span>)&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====消费消息"</span>+message.getMessageProperties().getConsumerQueue()+<span class="string">"===handleMessage"</span>);</span><br><span class="line">        System.out.println(message.getMessageProperties());</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认 rabbitListenerContainerFactory</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>@RabbitListener和@RabbitHandler搭配使用</strong></p>
<p>@RabbitListener可以标注在类上面，当使用在类上面的时候，需要配合@RabbitHandler注解一起使用，@RabbitListener标注在类上面表示当有收到消息的时候，就交给带有@RabbitHandler的方法处理，具体找哪个方法处理，需要跟进MessageConverter转换后的java对象。</p>
<p><strong>ReturnListener</strong></p>
<p>设置</p>
<ul>
<li><code>factory.setPublisherReturns(true);</code></li>
<li><code>rabbitTemplate.setMandatory(true);或rabbitTemplate.setMandatoryExpression(new SpelExpressionParser().parseExpression(&quot;(1+2) &gt; 2&quot;)); //表达式的值为true</code><br>才会触发returnCallback回调方法的执行。</li>
</ul>
<p><strong>发送确认（publisher confirms）</strong></p>
<p>RabbitMQ java Client实现发送确认deliveryTag（投递的标识），当Channel设置成confirm模式时，发布的每一条消息都会获得一个唯一的deliveryTag，任何channel上发布的第一条消息的deliveryTag为1，此后的每一条消息都会加1，deliveryTag在channel范围内是唯一的。</p>
<p><strong>消息可靠性的二种方式</strong></p>
<ol>
<li>事务，利用AMQP协议的一部分，发送消息前设置channel为tx模式（channel.txSelect();），如果txCommit提交成功了，则消息一定到达了broker了，如果在txCommit执行之前broker异常崩溃或者由于其他原因抛出异常，这个时候我们便可以捕获异常通过txRollback回滚事务了。（大大得削弱消息中间件的性能）</li>
<li>消息确认（publish confirms），设置管道为confirmSelect模式（channel.confirmSelect();）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Long id = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> TreeSet&lt;Long&gt; tags = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">send</span><span class="params">(Channel channel,<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder().deliveryMode(<span class="number">2</span>).</span><br><span class="line">                contentEncoding(<span class="string">"UTF-8"</span>).build();</span><br><span class="line">        channel.basicPublish(<span class="string">"zhihao.direct.exchange"</span>,<span class="string">"zhihao.miao.order"</span>,properties,bytes);</span><br><span class="line">        <span class="keyword">return</span> ++id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"></span><br><span class="line">        connectionFactory.setUri(<span class="string">"amqp://zhihao.miao:123456@192.168.1.131:5672"</span>);</span><br><span class="line"></span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line"></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是当前的channel处于确认模式</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使当前的channel处于事务模式，与上面的使channel处于确认模式使互斥的</span></span><br><span class="line">        <span class="comment">//channel.txSelect();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * deliveryTag 消息id</span></span><br><span class="line"><span class="comment">         * multiple 是否批量</span></span><br><span class="line"><span class="comment">         *      如果是true，就意味着，小于等于deliveryTag的消息都处理成功了</span></span><br><span class="line"><span class="comment">         *      如果是false，只是成功了deliveryTag这一条消息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.addConfirmListener(<span class="keyword">new</span> ConfirmListener() &#123;</span><br><span class="line">            <span class="comment">//消息发送成功并且在broker落地，deliveryTag是唯一标志符，在channek上发布的消息的deliveryTag都会比之前加1</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAck</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"=========deliveryTag=========="</span>);</span><br><span class="line">                System.out.println(<span class="string">"deliveryTag: "</span>+deliveryTag);</span><br><span class="line">                System.out.println(<span class="string">"multiple: "</span>+multiple);</span><br><span class="line">                <span class="comment">//处理成功发送的消息</span></span><br><span class="line">                <span class="keyword">if</span>(multiple)&#123;</span><br><span class="line">                    <span class="comment">//批量操作</span></span><br><span class="line">                    <span class="keyword">for</span>(Long _id:<span class="keyword">new</span> TreeSet&lt;&gt;(tags.headSet(deliveryTag+<span class="number">1</span>)))&#123;</span><br><span class="line">                        tags.remove(_id);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//单个确认</span></span><br><span class="line">                    tags.remove(deliveryTag);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"未处理的消息: "</span>+tags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * deliveryTag 消息id</span></span><br><span class="line"><span class="comment">             * multiple 是否批量</span></span><br><span class="line"><span class="comment">             *      如果是true，就意味着，小于等于deliveryTag的消息都处理失败了</span></span><br><span class="line"><span class="comment">             *      如果是false，只是失败了deliveryTag这一条消息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//消息发送失败或者落地失败</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"===========handleNack==========="</span>);</span><br><span class="line">                System.out.println(<span class="string">"deliveryTag: "</span>+deliveryTag);</span><br><span class="line">                System.out.println(<span class="string">"multiple: "</span>+multiple);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当Channel设置成confirm模式时，发布的每一条消息都会获得一个唯一的deliveryTag</span></span><br><span class="line"><span class="comment">         * deliveryTag在basicPublish执行的时候加1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Long id = send(channel,<span class="string">"你的外卖已经送达"</span>.getBytes());</span><br><span class="line">        tags.add(id);</span><br><span class="line">        <span class="comment">//channel.waitForConfirms();</span></span><br><span class="line"></span><br><span class="line">        id =send(channel,<span class="string">"你的外卖已经送达"</span>.getBytes());</span><br><span class="line">        tags.add(id);</span><br><span class="line">        <span class="comment">//channel.waitForConfirms();</span></span><br><span class="line"></span><br><span class="line">        id = send(channel,<span class="string">"呵呵，不接电话"</span>.getBytes());</span><br><span class="line">        tags.add(id);</span><br><span class="line">        <span class="comment">//channel.waitForConfirms();  </span></span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// channel.waitForConfirms():表示等待已经发送给broker的消息act或者nack之后才会继续执行。</span></span><br><span class="line"><span class="comment">// channel.waitForConfirmsOrDie():表示等待已经发送给broker的消息act或者nack之后才会继续执行，如果有任何一个消息触发了nack则抛出IOException。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">rabbitTemplate</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">    RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate(connectionFactory);</span><br><span class="line">    rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> RabbitTemplate.ConfirmCallback() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> correlationData 唯一标识，有了这个唯一标识，我们就知道可以确认（失败）哪一条消息了</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> ack</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> cause</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"=====消息进行消费了======"</span>);</span><br><span class="line">            <span class="keyword">if</span>(ack)&#123;</span><br><span class="line">                System.out.println(<span class="string">"消息id为: "</span>+correlationData+<span class="string">"的消息，已经被ack成功"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"消息id为: "</span>+correlationData+<span class="string">"的消息，消息nack，失败原因是："</span>+cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// public static void main(String[] args) throws Exception&#123;</span></span><br><span class="line"><span class="comment">//     AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(Application.class);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     RabbitTemplate rabbitTemplate = context.getBean(RabbitTemplate.class);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     Order order  = createOrder();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     saveOrder(order);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     ObjectMapper objectMapper = new ObjectMapper();</span></span><br><span class="line"><span class="comment">//     byte[] body = objectMapper.writeValueAsBytes(order);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     MessageProperties messageProperties = new MessageProperties();</span></span><br><span class="line"><span class="comment">//     messageProperties.setContentType("json");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     Message message = new Message(body,messageProperties);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     System.out.println("id: "+order.getOrderId());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     //指定correlationData的值</span></span><br><span class="line"><span class="comment">//     rabbitTemplate.send("zhihao.direct.exchange","zhihao.miao.order",message,new CorrelationData(order.getOrderId().toString()));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     TimeUnit.SECONDS.sleep(10);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     context.close();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入库操作</span></span><br><span class="line"><span class="comment">// id: 11bc9eb3-fbcb-4777-9596-b6f6db81cafc</span></span><br><span class="line"><span class="comment">// 十月 22, 2017 7:14:14 下午 org.springframework.amqp.rabbit.connection.CachingConnectionFactory createBareConnection</span></span><br><span class="line"><span class="comment">// 信息: Created new connection: connectionFactory#50ad3bc1:0/SimpleConnection@4efc180e [delegate=amqp://zhihao.miao@192.168.1.131:5672/, localPort= 61095]</span></span><br><span class="line"><span class="comment">// =====消息进行消费了======</span></span><br><span class="line"><span class="comment">// 消息id为: CorrelationData [id=11bc9eb3-fbcb-4777-9596-b6f6db81cafc]的消息，已经被ack成功</span></span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<p>生产者与broker之间的消息可靠性保证的基本思路就是</p>
<blockquote>
<p>当消息发送到broker的时候，会执行监听的回调函数，其中deliveryTag是消息id（在同一个channel中这个数值是递增的，而multiple表示是否批量确认消息。<br>在生产端要维护一个消息发送的表，消息发送的时候记录消息id，在消息成功落地broker磁盘并且进行回调确认（ack）的时候，根据本地消息表和回调确认的消息id进行对比，这样可以确保生产端的消息表中的没有进行回调确认（或者回调确认时网络问题）的消息进行补救式的重发，当然不可避免的就会在消息端可能会造成消息的重复消息。针对消费端重复消息，在消费端进行幂等处理。（丢消息和重复消息是不可避免的二个极端，比起丢消息，重复消息还有补救措施，而消息丢失就真的丢失了。</p>
</blockquote>
<p><strong>总结</strong><br>消费端的消息确认分为二个步骤，</p>
<p>在channel.basicConsume指定为手动确认。<br>具体根据业务逻辑来进行判断什么是ack什么时候nack（又分为要不要重新requeue）</p>
<p>做到消息不能丢失，我们就要实现可靠消息，做到这一点，我们要做到下面二点：</p>
<ol>
<li><p>持久化</p>
<ol>
<li>exchange要持久化</li>
<li>queue要持久化</li>
<li>message要持久化</li>
</ol>
</li>
<li><p>消息确认</p>
<ol>
<li>启动消费返回（@ReturnList注解，生产者就可以知道哪些消息没有发出去）</li>
<li>生产者和Server（broker）之间的消息确认。</li>
<li>消费者和Server（broker）之间的消息确认。</li>
</ol>
</li>
</ol>
<p><strong>总结</strong></p>
<ol>
<li>建议Alternate Exchange的类型是fanout，防止出现路由失败。</li>
<li>fanout exchange一般不需要指定Alternate Exchange属性。</li>
<li>如果一个Exchange指定了Alternate Exchange，那就意味着，当Exchange和Alternate Exchange都无法路由的时候，才会触发return method。</li>
</ol>
<p>RabbitMQ允许您为消息和队列设置TTL（生存时间）。 可以使用可选的队列参数或策略完成（推荐使用后一个选项）。 可以为单个队列，一组队列或单个消息应用消息TTL。</p>
<p>总结：</p>
<ul>
<li>创建优先级队列，需要增加x-max-priority参数，指定一个数字。表示最大的优先级，建议优先级设置为1～10之间。</li>
<li>发送消息的时候，需要设置priority属性，最好不要超过上面指定的最大的优先级。</li>
<li>如果生产端发送很慢，消费者消息很快，则有可能不会严格的按照优先级来进行消费。</li>
<li>第一，如果发送的消息的优先级属性小于设置的队列属性x-max-priority值，则按优先级的高低进行消费，数字越高则优先级越高。</li>
<li>第二，如果发送的消息的优先级属性都大于设置的队列属性x-max-priority值，则设置的优先级失效，按照入队列的顺序进行消费。</li>
<li>第三，如果消费端一直进行监听，而发送端一条条的发送消息，优先级属性也会失效。</li>
</ul>
<p>RabbitMQ不能保证消息的严格的顺序消费。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/kpkym/2019/09/14/总结/RabbitMQ 总结/" data-id="ckkdeehbq000sp5jz9t2ibjbx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/总结/">总结</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-总结/docker 总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/01/总结/docker 总结/" class="article-date">
  <time datetime="2018-12-01T08:36:03.000Z" itemprop="datePublished">2018-12-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Docker/">Docker</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/01/总结/docker 总结/">Docker 总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
</blockquote>
<p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p>
<h1 id="Docker镜像加载原理："><a href="#Docker镜像加载原理：" class="headerlink" title="Docker镜像加载原理："></a>Docker镜像加载原理：</h1><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。<br>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p>
<blockquote>
<p>rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。<br>。 </p>
</blockquote>
<p>平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？？</p>
<blockquote>
<p>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。</p>
</blockquote>
<h1 id="为什么-Docker-镜像要采用这种分层结构呢"><a href="#为什么-Docker-镜像要采用这种分层结构呢" class="headerlink" title="为什么 Docker 镜像要采用这种分层结构呢"></a>为什么 Docker 镜像要采用这种分层结构呢</h1><p>最大的一个好处就是 - 共享资源</p>
<blockquote>
<p>比如：有多个镜像都从相同的 base 镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像，<br>同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p>
</blockquote>
<p><strong>Docker镜像都是只读的</strong><br>当容器启动时，一个新的可写层被加载到镜像的顶部。<br>这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p>
<ol>
<li>docker commit提交容器副本使之成为一个新的镜像</li>
<li>docker commit -m=“提交的描述信息” -a=“作者” 容器ID 要创建的目标镜像名:[标签名]</li>
</ol>
<p>Docker解决了运行环境和配置问题软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。</p>
<blockquote>
<p>由于前面虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。<br>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。</p>
</blockquote>
<h1 id="比较了-Docker-和传统虚拟化方式的不同之处："><a href="#比较了-Docker-和传统虚拟化方式的不同之处：" class="headerlink" title="比较了 Docker 和传统虚拟化方式的不同之处："></a>比较了 Docker 和传统虚拟化方式的不同之处：</h1><ul>
<li>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；</li>
<li>而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</li>
<li>每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。</li>
</ul>
<h1 id="Docker是怎么工作的"><a href="#Docker是怎么工作的" class="headerlink" title="Docker是怎么工作的:"></a>Docker是怎么工作的:</h1><blockquote>
<p>Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 容器，是一个运行时环境，就是我们前面说到的集装箱。</p>
</blockquote>
<h2 id="为什么Docker比较比VM快"><a href="#为什么Docker比较比VM快" class="headerlink" title="为什么Docker比较比VM快"></a>为什么Docker比较比VM快</h2><ol>
<li>docker有着比虚拟机更少的抽象层。由亍docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</li>
<li>docker利用的是宿主机的内核,而不需要Guest OS。因此,当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引寻、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载Guest OS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返个过程,因此新建一个docker容器只需要几秒钟。</li>
</ol>
<p>帮助命令<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br><span class="line">docker info</span><br><span class="line">docker --help</span><br></pre></td></tr></table></figure></p>
<p>镜像命令<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">docker search 某个XXX镜像名字</span><br><span class="line"></span><br><span class="line">docker pull 某个XXX镜像名字</span><br><span class="line">docker pull 镜像名字[:TAG]</span><br><span class="line"></span><br><span class="line">docker rmi 某个XXX镜像名字ID</span><br><span class="line">docker rmi  -f 镜像ID</span><br><span class="line">docker rmi -f 镜像名1:TAG 镜像名2:TAG </span><br><span class="line">docker rmi -f $(docker images -qa)</span><br></pre></td></tr></table></figure></p>
<p>exit 退出交互式界面，容器停止运行<br>Crtl+P 或者Crtl+Q 退出交互式界面，容器在后台运行。(注意是大写P和Q)</p>
<p>容器操作<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker create 容器名或者容器ID 创建容器</span><br><span class="line">docker start [-i] 容器名       启动容器</span><br><span class="line">docker run 容器名或者容器ID    运行容器，相当于docker create + docker start</span><br><span class="line">docker attach 容器名或者容器ID 进入容器的命令行</span><br><span class="line">docker stop 容器名                             停止容器</span><br><span class="line">docker rm 容器名                               删除容器</span><br><span class="line"></span><br><span class="line">docker top 容器名          查看WEB应用程序容器的进程</span><br><span class="line">docker inspect 容器名 查看Docker的底层信息</span><br></pre></td></tr></table></figure></p>
<p>守护式容器<br>我们可以使用守护式容器运行一个或者多个服务，例如运行lamp服务、redis服务、mysql服务等。</p>
<p>什么是守护式容器？</p>
<ul>
<li>能够长期运行</li>
<li>没有交互式会话</li>
<li>适合运行应用程序和服务</li>
<li>启动守护式容器：</li>
</ul>
<p>docker run -d IMAGE [COMMOND] [ARG…]</p>
<blockquote>
<p><a href="https://webkul.com/blog/docker-container-will-automatically-stop-run/" target="_blank" rel="noopener">https://webkul.com/blog/docker-container-will-automatically-stop-run/</a><br>Docker Container stopped automatically after starting. You can check exit code of container if it is 0 means container exited after all exection, means you have to run the process in foreground to keep container running</p>
</blockquote>
<h1 id="Docker容器数据卷"><a href="#Docker容器数据卷" class="headerlink" title="Docker容器数据卷"></a>Docker容器数据卷</h1><blockquote>
<p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：<br>卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷</p>
</blockquote>
<p><strong>特点：</strong></p>
<ol>
<li>数据卷可在容器之间共享或重用数据</li>
<li>卷中的更改可以直接生效</li>
<li>数据卷中的更改不会包含在镜像的更新中</li>
<li>数据卷的生命周期一直持续到没有容器使用它为止</li>
</ol>
<p>命令</p>
<blockquote>
<p>docker run -it -v /宿主机目录:/容器内目录 centos /bin/bash</p>
</blockquote>
<p>查看数据卷是否挂载成功</p>
<blockquote>
<p>docker inspect 容器ID</p>
</blockquote>
<p>命令(带权限)</p>
<blockquote>
<p>docker run -it -v /宿主机绝对路径目录:/容器内目录:ro 镜像名</p>
</blockquote>
<p>DockerFile添加</p>
<blockquote>
<p>根目录下新建mydocker文件夹并进入<br><code>VOLUME[&quot;/dataVolumeContainer&quot;,&quot;/dataVolumeContainer2&quot;,&quot;/dataVolumeContainer3&quot;]</code></p>
</blockquote>
<p>说明：</p>
<blockquote>
<p>出于可移植和分享的考虑，用-v 主机目录:容器目录这种方法不能够直接在Dockerfile中实现。由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有的宿主机上都存在这样的特定目录。</p>
</blockquote>
<h1 id="File构建"><a href="#File构建" class="headerlink" title="File构建"></a>File构建</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># volume test</span><br><span class="line">FROM centos</span><br><span class="line">VOLUME ["/dataVolumeContainer1","/dataVolumeContainer2"]</span><br><span class="line">CMD echo "finished,--------success1"</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure>
<h2 id="容器间传递共享-–volumes-from"><a href="#容器间传递共享-–volumes-from" class="headerlink" title="容器间传递共享(–volumes-from)"></a>容器间传递共享(–volumes-from)</h2><blockquote>
<p>结论：容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止</p>
</blockquote>
<h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><blockquote>
<p>Dockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。</p>
</blockquote>
<h2 id="构建三步骤"><a href="#构建三步骤" class="headerlink" title="构建三步骤"></a>构建三步骤</h2><ol>
<li>编写Dockerfile文件</li>
<li>docker build</li>
<li>docker run</li>
</ol>
<h2 id="DockerFile构建过程解析"><a href="#DockerFile构建过程解析" class="headerlink" title="DockerFile构建过程解析"></a>DockerFile构建过程解析</h2><h3 id="Dockerfile内容基础知识"><a href="#Dockerfile内容基础知识" class="headerlink" title="Dockerfile内容基础知识"></a>Dockerfile内容基础知识</h3><ol>
<li>每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li>
<li>指令按照从上到下，顺序执行</li>
<li>#表示注释</li>
<li>每条指令都会创建一个新的镜像层，并对镜像进行提交</li>
</ol>
<h3 id="Docker执行Dockerfile的大致流程"><a href="#Docker执行Dockerfile的大致流程" class="headerlink" title="Docker执行Dockerfile的大致流程"></a>Docker执行Dockerfile的大致流程</h3><ol>
<li>docker从基础镜像运行一个容器</li>
<li>执行一条指令并对容器作出修改</li>
<li>执行类似docker commit的操作提交一个新的镜像层</li>
<li>docker再基于刚提交的镜像运行一个新容器</li>
<li>执行dockerfile中的下一条指令直到所有指令都执行完成</li>
</ol>
<p>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段，</p>
<ul>
<li>Dockerfile是软件的原材料</li>
<li>Docker镜像是软件的交付品</li>
<li>Docker容器则可以认为是软件的运行态。</li>
</ul>
<blockquote>
<p>Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。</p>
</blockquote>
<ol>
<li>Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;</li>
<li>Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行 Docker镜像时，会真正开始提供服务;</li>
<li>Docker容器，容器是直接提供服务的。</li>
</ol>
<h1 id="DockerFile体系结构-保留字指令"><a href="#DockerFile体系结构-保留字指令" class="headerlink" title="DockerFile体系结构(保留字指令)"></a>DockerFile体系结构(保留字指令)</h1><ol>
<li><code>FROM</code> | 基础镜像，当前新镜像是基于哪个镜像的</li>
<li><code>MAINTAINER</code> | 镜像维护者的姓名和邮箱地址</li>
<li><code>RUN</code> | 容器构建时需要运行的命令</li>
<li><code>EXPOSE</code> | 当前容器对外暴露出的端口</li>
<li><code>WORKDIR</code> | 指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点</li>
<li><code>ENV</code> | 用来在构建镜像过程中设置环境变量</li>
<li><code>ADD</code> | 将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包</li>
<li><code>COPY</code> | 类似ADD，拷贝文件和目录到镜像中。 | 将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置</li>
<li><code>VOLUME</code> | 容器数据卷，用于数据保存和持久化工作</li>
<li><code>CMD</code> | 指定一个容器启动时要运行的命令 | Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换</li>
<li><code>ENTRYPOINT</code>  | 指定一个容器启动时要运行的命令 | ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数</li>
<li><code>ONBUILD</code> | 当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/kpkym/2018/12/01/总结/docker 总结/" data-id="ckkdeehbn000np5jzzj0xqmlh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/总结/">总结</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-计算机网络/6 第六章 应用层" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/31/计算机网络/6 第六章 应用层/" class="article-date">
  <time datetime="2018-03-31T12:36:22.000Z" itemprop="datePublished">2018-03-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/31/计算机网络/6 第六章 应用层/">应用层</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><ol>
<li>根域名服务器</li>
<li>顶级域名服务器</li>
<li>权限域名服务器</li>
<li>本地域名服务器</li>
</ol>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>HTTP/1.1使用持续连接解决HTTP/1.0的非持续连接</p>
<h1 id="本章的重要概念"><a href="#本章的重要概念" class="headerlink" title="本章的重要概念"></a>本章的重要概念</h1><ul>
<li>应用层协议是为了解决某一类应用问题，而问题的解决又是通过位于不同主机中的多个应用进程之间的通信和协同工.作来完成的。应用层规定了应用进程在通信时所遵循的协议。应用层的许多协议都是基于客户服务器方式的。客户是服务请求方，服务器是服务提供方。</li>
<li>域名系统DNS 是因特网使用的命名系统，用来把便于人们使用的机器名字转换为IP地址。DNS 是一个联机分布式数据库系统，并采用客户服务器方式。</li>
<li>域名到IP 地址的解析是由分布在因特网上的许多域名服务器程序(即域名服务器) 共同完成的。</li>
<li>因特网采用层次树状结构的命名方法，任何一台连接在因特网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。域名中的点和点分十进制IP 地址中的点没有关系。</li>
<li>域名服务器分为根域名服务器、顶级域名服务器、权限域名服务器和本地域名服务器。</li>
<li>文件传送协议FTP 使用TCP 可靠的运输服务。FTP 使用客户服务器方式。一个FTP服务器进程可同时为多个客户进程提供服务。在进行文件传输时，FTP的客户和服务器之间要建立两个并行的TCP 连接: 控制连接和数据连接。实际用于传输文件的是数据连接。</li>
<li>万维网WWW 是一个大规模的、联机式的信息储藏所，可以非常方便地从因特网上的一个站点链接到另一个站点。</li>
<li>万维网的客户程序向因特网中的服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档。在客户程序主窗口上显示出的万维网文档称为页面。</li>
<li>万维网使用统一资源定位符URL 来标志万维网上的各种文档，并使每一个文档在整个因特网的范围内具有唯一的标识符URL.</li>
<li>万维网客户程序与服务器程序之间进行交互所使用的协议是超文本传送协议HTTP.HTTP使用TCP连接进行可靠的传送。但HTTP协议本身是无连接，无状态的。HTTP/1.1协议使用了持续连接(分为非流水线方式和流水线方式)。</li>
<li>万维网使用超文本标记语言HTML来显示各种万维网页面。</li>
<li>万维网静态文档是指在文档创作完毕后就存放在万维网服务器中，在被用户浏览的过程中，内容不会改变。动态文档是指文档的内容是在浏览器访问万维网服务器时才由应用程序动态创建的。</li>
<li>活动文档技术可以使浏览器屏幕连续更新。活动文档程序可与用户直接交互，并可连续地改变屏幕的显示。</li>
<li>在万维网中用来进行搜索的工具叫做搜索引擎。搜索引擎大体上可划分为全文检索搜索引擎和分类目录搜索引擎两大类.</li>
<li>电子邮件是因特网，上使用最多的和最受用户欢迎的一种应用。电子邮件把邮件发送到收件人使用的邮件服务器，放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器进行读取.相当于“电子信箱”。</li>
<li>一个电子邮件系统有三个主要组成构件，即: 用户代理、邮件服务器，以及邮件协议(包括邮件发送协议，如SMTP,和邮件读取协议，如POP3).用户代理和邮件服务器都要运行这两种协议。</li>
<li>电子邮件的用户代理就是用户与电子邮件系统的接口，它向用户提供一个很友好的视窗界面来发送和接收邮件。</li>
<li>从用户代理把邮件传送到邮件服务器，以及在邮件服务器之间的传送，都要使用SMTP协议。但用户代理从邮件服务器读取邮件时，则要使用POP3 (或IMAP)协议。</li>
<li>基于万维网的电子邮件使用户能够利用浏览器收发电子邮件。用户浏览器和邮件服务器之间的邮件传送使用HTTP 协议，而在邮件服务器之间邮件的传送仍然使用SMTP 协议。</li>
<li>简单网络管理协议SNMP由部分组成，即:<ul>
<li>(1) SNMP本身，负责读取和改变各代理中的对象名及其状态数值。</li>
<li>(2) 管理信息结构SMI,定义命名对象和定义对象类型(包括范围和长度) 的通用规则，以及把对象和对象的值进行编码的基本编码规则BER.</li>
<li>(3) 管理信息库MIB，t 被管理的实体中创建了命名对象，并规定了其类型。</li>
</ul>
</li>
<li>系统调用接口是应用进程的控制权和操作系统的控制权进行转换的一个接口，又称为应用编程接口API。API 就是应程序和操作系统之间的接口。</li>
<li>套接字是应用进程和运输层协议之间的接口，是应用进程为了获得网络通信服务而与操作系统进行交互时使用的一种机制。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/kpkym/2018/03/31/计算机网络/6 第六章 应用层/" data-id="ckkdeehbq000rp5jzvojj0bgk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-总结/Redis 总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/25/总结/Redis 总结/" class="article-date">
  <time datetime="2018-03-25T08:33:16.000Z" itemprop="datePublished">2018-03-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Redis/">Redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/25/总结/Redis 总结/">Redis 总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>config set password ‘123456’</li>
<li>auth 123456</li>
</ul>
<p><strong>ps -ef|grep redis</strong></p>
<ul>
<li>select 切换数据库</li>
<li>dbsize 常看当前数据库的key的数量</li>
<li>flushdb 清空当前数据库</li>
<li>flushall 清空全部数据库</li>
<li>统一密码管理，16个库都是同样密码</li>
</ul>
        
          <p class="article-more-link">
            <a href="/2018/03/25/总结/Redis 总结/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/kpkym/2018/03/25/总结/Redis 总结/" data-id="ckkdeehbf000bp5jzls0iadwh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/总结/">总结</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-计算机网络/5 第五章 运输层" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/17/计算机网络/5 第五章 运输层/" class="article-date">
  <time datetime="2018-03-17T07:43:58.000Z" itemprop="datePublished">2018-03-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/17/计算机网络/5 第五章 运输层/">运输层</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="运输层协议概述"><a href="#运输层协议概述" class="headerlink" title="运输层协议概述"></a>运输层协议概述</h1><h2 id="进程之间的通信"><a href="#进程之间的通信" class="headerlink" title="进程之间的通信"></a>进程之间的通信</h2><p>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。</p>
<h1 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h1><h2 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a>连续 ARQ 协议</h2><p>连续 ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置，接收方一般都是采用<strong>积累确认</strong>的方式。这就是说，接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对按序列到达的最后一个分组发送确认，这就表示：到这个分组位置的所有分组都已正确收到了。</p>
<p>累积确认有优点也有缺点。</p>
<ul>
<li>优点是: 容易实现，即使确认丢失也不必重传。</li>
<li>但缺点是不能向发送方反映出接收方已经正确收到的所有分组的信息。<blockquote>
<p>例如，如果发送方发送了前5个分組，而中间的第3个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。这就叫做Go-back-N (回退N)，表示需要再退回来重传已发送过的N个分组。可见当通信线路质量不好时，连续ARQ协议会带来负面的影响。</p>
</blockquote>
</li>
</ul>
        
          <p class="article-more-link">
            <a href="/2018/03/17/计算机网络/5 第五章 运输层/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/kpkym/2018/03/17/计算机网络/5 第五章 运输层/" data-id="ckkdeehbp000qp5jz3xynw8f2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-总结/Linux" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/01/总结/Linux/" class="article-date">
  <time datetime="2018-03-01T02:12:42.000Z" itemprop="datePublished">2018-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/01/总结/Linux/">Linux 总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Linux-系统启动过程"><a href="#Linux-系统启动过程" class="headerlink" title="Linux 系统启动过程"></a>Linux 系统启动过程</h1><ol>
<li>内核的引导。<blockquote>
<p>当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。<br>操作系统接管硬件以后，首先读入 /boot 目录下的内核文件。</p>
</blockquote>
</li>
<li>运行 init。<blockquote>
<p>init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。<br>init 程序首先是需要读取配置文件 /etc/inittab。</p>
</blockquote>
</li>
<li>系统初始化。<blockquote>
<p>许多程序需要开机启动。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）。<br>init进程的一大任务，就是去运行这些开机启动的程序。<br>但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动Apache，用作桌面就不需要。<br>Linux允许为不同的场合，分配不同的开机启动程序，这就叫做”运行级别”（runlevel）。也就是说，启动时根据”运行级别”，确定要运行哪些程序。</p>
<blockquote>
<p>Linux系统有7个运行级别(runlevel)：<br>运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动<br>运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆<br>运行级别2：多用户状态(没有NFS)<br>运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式<br>运行级别4：系统未使用，保留<br>运行级别5：X11控制台，登陆后进入图形GUI模式<br>运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</p>
</blockquote>
</blockquote>
</li>
<li>建立终端 。</li>
<li>用户登录系统。</li>
</ol>
<h2 id="运行级别说明"><a href="#运行级别说明" class="headerlink" title="运行级别说明:"></a>运行级别说明:</h2><blockquote>
<p><code>0.</code> 关机<br><code>1.</code> 单用户【找回丢失密码】<br><code>2.</code> 多用户状态没有网络服务<br><code>3.</code> 多用户状态有网络服务<br><code>4.</code> 系统未使用保留给用户<br><code>5.</code> 图形界面<br><code>6.</code> 系统重启</p>
</blockquote>
<blockquote>
<p>常用运行级别是 3 和 5 ，要修改默认的运行级别可改文件 /etc/inittab 的 id:5:initdefault:这一行中的数字</p>
</blockquote>
<p><strong>强制覆盖不提示的方法:\cp</strong></p>
<h1 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h1><p>-e 编辑  |  -l 查询  | -r 删除</p>
<ol>
<li>cron -e</li>
<li>*/1<em>**</em>ls-l/etc&gt;&gt;/tmp/to.txt</li>
<li>当保存退出后就程序。</li>
<li>在每一分钟都会自动的调用 ls -l /etc &gt;&gt; /tmp/to.txt</li>
</ol>
<blockquote>
<p>分 时 日 月 星期 要运行的命令<br>第1列分钟0～59<br>第2列小时0～23（0表示子夜）<br>第3列日1～31<br>第4列月1～12<br>第5列星期0～7（0和7表示星期天）<br>第6列要运行的命令</p>
<blockquote>
<p>minute   hour   day   month   week   command</p>
</blockquote>
</blockquote>
<p>其中：</p>
<blockquote>
<p>minute： 表示分钟，可以是从0到59之间的任何整数。<br>hour：表示小时，可以是从0到23之间的任何整数。<br>day：表示日期，可以是从1到31之间的任何整数。<br>month：表示月份，可以是从1到12之间的任何整数。<br>week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。<br>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</p>
</blockquote>
<p>在以上各个字段中，还可以使用以下特殊字符：<br>星号（<em>）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。<br>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”<br>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”<br>正斜线（/）$$：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如</em>/10，如果用在minute字段，表示每十分钟执行一次。</p>
<h1 id="SCSI"><a href="#SCSI" class="headerlink" title="SCSI"></a>SCSI</h1><ol start="2">
<li>对于 IDE 硬盘，驱动器标识符为“hdx~”,其中“hd”表明分区所在设备的类型，这里是指 IDE 硬 盘了。“x”为盘号(a 为基本盘，b 为基本从属盘，c 为辅助主盘，d 为辅助从属盘),“~”代表分区， 前四个分区用数字 1 到 4 表示，它们是主分区或扩展分区，从 5 开始就是逻辑分区。例，hda3 表示为 第一个 IDE 硬盘上的第三个主分区或扩展分区,hdb2 表示为第二个 IDE 硬盘上的第二个主分区或扩展 分区。</li>
<li>对于 SCSI 硬盘则标识为“sdx~”，SCSI 硬盘是用“sd”来表示分区所在设备的类型的，其余则 和 IDE 硬盘的表示方法一样。</li>
</ol>
<h2 id="如何增加一块硬盘"><a href="#如何增加一块硬盘" class="headerlink" title="如何增加一块硬盘"></a>如何增加一块硬盘</h2><ol>
<li>虚拟机添加硬盘</li>
<li>分区 fdisk /dev/sdb</li>
<li>格式化 mkfs -t ext4 /dev/sdb1</li>
<li>挂载 先创建一个 /home/newdisk , 挂载 mount /dev/sdb1 /home/newdisk 5)设置可以自动挂载(永久挂载，当你重启系统，仍然可以挂载到 /home/newdisk) 。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/fstab</span><br><span class="line">/dev/sdb1 /home/newdisk ext4 defaults 0 0</span><br></pre></td></tr></table></figure>
<p><strong>查询系统整体磁盘使用情况 df -lh</strong></p>
<h2 id="查看服务名"><a href="#查看服务名" class="headerlink" title="查看服务名"></a>查看服务名</h2><ul>
<li>方式 1:使用 setup -&gt; 系统服务 就可以看到。</li>
<li>方式 2: /etc/init.d/服务名称</li>
</ul>
<h1 id="查看或者修改默认级别-vi-etc-inittab"><a href="#查看或者修改默认级别-vi-etc-inittab" class="headerlink" title="查看或者修改默认级别: vi /etc/inittab"></a>查看或者修改默认级别: vi /etc/inittab</h1><p><strong>Linux 系统有 7 种运行级别(runlevel):常用的是级别 3 和 5</strong></p>
<ul>
<li>运行级别 0:系统停机状态，系统默认运行级别不能设为 0，否则不能正常启动</li>
<li>运行级别 1:单用户工作状态，root 权限，用于系统维护，禁止远程登陆</li>
<li>运行级别 2:多用户状态(没有 NFS)，不支持网络</li>
<li>运行级别 3:完全的多用户状态(有 NFS)，登陆后进入控制台命令行模式</li>
<li>运行级别 4:系统未使用，保留</li>
<li>运行级别 5:X11 控制台，登陆后进入图形 GUI 模式</li>
<li>运行级别 6:系统正常关闭并重启，默认运行级别不能设为 6，否则不能正常启动</li>
</ul>
<p><strong>通过 chkconfig 命令可以给每个服务的各个运行级别设置自启动/关闭</strong></p>
<p><strong>查看系统网络情况 netstat</strong></p>
<blockquote>
<p>-an 按一定顺序排列输出 -p 显示哪个进程在调用</p>
</blockquote>
<h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><ol>
<li>脚本以#!/bin/bash 开头</li>
<li>脚本需要有可执行权限</li>
</ol>
<h2 id="Shell-的变量的介绍"><a href="#Shell-的变量的介绍" class="headerlink" title="Shell 的变量的介绍"></a>Shell 的变量的介绍</h2><ol>
<li>Linux Shell 中的变量分为，系统变量和用户自定义变量。</li>
<li>系统变量:$HOME、$PWD、$SHELL、$USER 等等<blockquote>
<p>比如: echo $HOME 等等..</p>
</blockquote>
</li>
<li>显示当前 shell 中所有变量:set</li>
</ol>
<p><strong>单引号字符串的限制：</strong></p>
<blockquote>
<p>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；<br>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</p>
</blockquote>
<p><strong>双引号的优点：</strong></p>
<blockquote>
<p>双引号里可以有变量<br>双引号里可以出现转义字符</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取字符串长度</span></span><br><span class="line">string=<span class="string">"abcd"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#string&#125;</span> <span class="comment">#输出 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取子字符串</span></span><br><span class="line"><span class="comment"># 以下实例从字符串第 2 个字符开始截取 4 个字符：</span></span><br><span class="line">string=<span class="string">"runoob is a great site"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;string:1:4&#125;</span> <span class="comment"># 输出 unoo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找子字符串</span></span><br><span class="line"><span class="comment"># 查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)：</span></span><br><span class="line">string=<span class="string">"runoob is a great site"</span></span><br><span class="line"><span class="built_in">echo</span> `expr index <span class="string">"<span class="variable">$string</span>"</span> io`  <span class="comment"># 输出 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数组</span></span><br><span class="line"><span class="comment"># 在 Shell 中，用括号来表示数组，数组元素用"空格"符号分割开。定义数组的一般形式为：</span></span><br><span class="line"><span class="comment"># 数组名=(值1 值2 ... 值n)</span></span><br><span class="line"><span class="comment"># 读取数组</span></span><br><span class="line"><span class="comment"># 读取数组元素值的一般格式是：</span></span><br><span class="line"><span class="variable">$&#123;数组名[下标]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 @ 符号可以获取数组中的所有元素，例如：</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array_name[@]&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数组的长度</span></span><br><span class="line"><span class="comment"># 获取数组长度的方法与获取字符串长度的方法相同，例如：</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># $n (功能描述:n 为数字，$0 代表命令本身，$1-$9 代表第一到第九个参数，十以上的参数，十 以上的参数需要用大括号包含，如$&#123;10&#125;)</span></span><br><span class="line"><span class="comment"># $* (功能描述:这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体) $@(功能描述:这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待) $#(功能描述:这个变量代表命令行中所有参数的个数)</span></span><br></pre></td></tr></table></figure>
<h2 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h2><blockquote>
<p>就是 shell 设计者事先已经定义好的变量，可以直接在 shell 脚本中使用</p>
</blockquote>
<blockquote>
<p>$$ (功能描述:当前进程的进程号(PID))<br>$! (功能描述:后台运行的最后一个进程的进程号(PID))<br>$? (功能描述:最后一次执行的命令的返回状态。如果这个变量的值为 0，证明上一个命令</p>
<blockquote>
<p>正确执行;如果这个变量的值为非 0(具体是哪个数，由命令自己来决定)，则证明上一个命令 执行不正确了。)</p>
</blockquote>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取得数组元素的个数</span></span><br><span class="line">length=<span class="variable">$&#123;#array_name[@]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">length=<span class="variable">$&#123;#array_name[*]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取得数组单个元素的长度</span></span><br><span class="line">lengthn=<span class="variable">$&#123;#array_name[n]&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h2><p>多行注释还可以使用以下格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">:&lt;&lt;EOF</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">EOF</span><br><span class="line">EOF 也可以使用其他符号:</span><br><span class="line"></span><br><span class="line">:&lt;&lt;&apos;</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">:&lt;&lt;!</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">!</span><br></pre></td></tr></table></figure></p>
<ol>
<li>定义变量:变量=值</li>
<li>撤销变量:unset 变量</li>
<li>声明静态变量:readonly 变量，注意:不能 unset</li>
</ol>
<h2 id="将命令的返回值赋给变量-重点"><a href="#将命令的返回值赋给变量-重点" class="headerlink" title="将命令的返回值赋给变量(重点)"></a>将命令的返回值赋给变量(重点)</h2><ol>
<li>A=<code>ls -la</code> 反引号，运行里面的命令，并把结果返回给变量 A</li>
<li>A=$(ls -la) 等价于反引号</li>
</ol>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ol>
<li>“$((运算式))”或“$[运算式]”</li>
<li>expr m + n<blockquote>
<p><strong>注意 expr 运算符间要有空格</strong></p>
</blockquote>
</li>
<li>expr m - n</li>
<li>expr *, /, % 乘，除，取余</li>
</ol>
<h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ condition ](注意 condition 前后要有空格)</span><br><span class="line"><span class="comment"># 非空返回 true，可使用$?验证(0 为 true，&gt;1 为 false)</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/kpkym/2018/03/01/总结/Linux/" data-id="ckkdeehbm000lp5jz5pbq3pyw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/总结/">总结</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-计算机网络/4 第四章 网络层" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/12/计算机网络/4 第四章 网络层/" class="article-date">
  <time datetime="2018-02-12T09:04:11.000Z" itemprop="datePublished">2018-02-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/12/计算机网络/4 第四章 网络层/">网络层</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>因特网的设计思路是这样的：网络层线上只提供简单灵活、无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺。可靠性由运输层负责</strong></p>
<h1 id="网际协议IP"><a href="#网际协议IP" class="headerlink" title="网际协议IP"></a>网际协议IP</h1><p>与IP协议配套使用的还有三个协议：</p>
<ul>
<li>地址解析协议ARP</li>
<li>网际控制报文协议ICMP</li>
<li>网际组管理协议IGMP<blockquote>
<p>本来还有一个协议叫逆地址解析协议RARP，是和ARP协议配合使用的。但现在已被淘汰不使用了。</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ICMP IGMP</span><br><span class="line">    IP</span><br><span class="line">        ARP</span><br></pre></td></tr></table></figure>
<p>因此TCP/IP层体系中的网络层常常称为网际层或IP层</p>
<p><strong>一般的概念来讲，将网络互相连接起来要使用一些中间设备。根据中间所在的层次，可以有以下四种中间设备。</strong></p>
<ol>
<li>物理层使用的中间设备叫做转发器。</li>
<li>数据链路层使用的中间设备叫做网桥或桥接器</li>
<li>网络层使用的中间设备叫做路由器</li>
<li>在网络层以上使用的中间设备叫做网关。用网关连接两个不兼容的系统需要在高层进行协议的转换</li>
</ol>
<p>从IP地址的结构来看，IP地址并不仅仅指明一个主机，而是还指明了主机所连接到的网络</p>
        
          <p class="article-more-link">
            <a href="/2018/02/12/计算机网络/4 第四章 网络层/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/kpkym/2018/02/12/计算机网络/4 第四章 网络层/" data-id="ckkdeehbo000op5jzk1ucc2cw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-总结/JavaScript 总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/05/总结/JavaScript 总结/" class="article-date">
  <time datetime="2018-02-05T08:20:57.000Z" itemprop="datePublished">2018-02-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/05/总结/JavaScript 总结/">JavaScript 总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>启用strict模式的方法是在JavaScript代码的第一行写上：</p>
<p>‘use strict’;</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`这是一个</span></span><br><span class="line"><span class="string">多行</span></span><br><span class="line"><span class="string">字符串`</span>;</span><br></pre></td></tr></table></figure>
<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'小明'</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">`你好, <span class="subst">$&#123;name&#125;</span>, 你今年<span class="subst">$&#123;age&#125;</span>岁了!`</span>;</span><br><span class="line">alert(message);</span><br></pre></td></tr></table></figure>
        
          <p class="article-more-link">
            <a href="/2018/02/05/总结/JavaScript 总结/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/kpkym/2018/02/05/总结/JavaScript 总结/" data-id="ckkdeehbc0008p5jzmcqa48cj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/总结/">总结</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-计算机网络/3 第三章 数据链路层" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/16/计算机网络/3 第三章 数据链路层/" class="article-date">
  <time datetime="2018-01-16T08:45:20.000Z" itemprop="datePublished">2018-01-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/16/计算机网络/3 第三章 数据链路层/">数据链路层</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h1><p>数据链路层协议有许多种.但有三个基本问题则是共同的.这三个基本问题是：封装成帧、透明传输和差错检测，下面分别讨论这三个基本问题，</p>
<p><strong>最大传送单元MTU</strong></p>
<h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><p>为了解决透明传输问题，就必须设法使数据中可能出现的控制字符“SOH”和“EOT”在接收端不被解释为控制字符。具体的方法是:发送端的数据链路层在数据中出现控制字符的前面插入一一个转义字符“ESC”(其十六进制编码是1B,进制是“SOH”或“EOT”00011011)。而在接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符。这种方法称为字节填充(byte stuffing)或字符填充(character stuffing)。如果转义字符也出现在数据当中，那么解决方法仍然是在转义字符的前面插入一个转义字符。因此,当接收端收到连续的两个转义字符时，就刪除其中前面的一个。图3-7 表示用字节填充法解决透明传输的问题。<br><img src="http://ww1.sinaimg.cn/large/005UDS28gy1fpe9w0dk3qj30ny0aqmxn.jpg" alt></p>
        
          <p class="article-more-link">
            <a href="/2018/01/16/计算机网络/3 第三章 数据链路层/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/kpkym/2018/01/16/计算机网络/3 第三章 数据链路层/" data-id="ckkdeehbr000tp5jzm6jvr8cq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-总结/Git 总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/11/总结/Git 总结/" class="article-date">
  <time datetime="2018-01-11T13:53:08.000Z" itemprop="datePublished">2018-01-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Git/">Git</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/11/总结/Git 总结/">Git 总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">Git教程(廖雪峰)</a></p>
<h1 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h1><ul>
<li>git config –global user.name “Your Name”</li>
<li>git config –global user.email “<a href="mailto:email@example.com" target="_blank" rel="noopener">email@example.com</a>“</li>
<li>git config –list <blockquote>
<p>注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
</blockquote>
</li>
</ul>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><ul>
<li>git init</li>
<li>git diff</li>
<li>git add &lt;file></li>
<li>git commit</li>
<li>git status</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/005UDS28gy1fphjs9fdwoj30dd0cngmi.jpg" alt></p>
        
          <p class="article-more-link">
            <a href="/2018/01/11/总结/Git 总结/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/kpkym/2018/01/11/总结/Git 总结/" data-id="ckkdeehba0006p5jz34198bx2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/总结/">总结</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Head-First-Servlets-and-JSP/">Head First Servlets and JSP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/中间件/">中间件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/正则表达式/">正则表达式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/总结/">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/总结/" style="font-size: 20px;">总结</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/设计模式/" style="font-size: 20px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/09/14/总结/RabbitMQ 总结/">RabbitMQ 总结</a>
          </li>
        
          <li>
            <a href="/2018/12/01/总结/docker 总结/">Docker 总结</a>
          </li>
        
          <li>
            <a href="/2018/03/31/计算机网络/6 第六章 应用层/">应用层</a>
          </li>
        
          <li>
            <a href="/2018/03/25/总结/Redis 总结/">Redis 总结</a>
          </li>
        
          <li>
            <a href="/2018/03/17/计算机网络/5 第五章 运输层/">运输层</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 kpkym<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>