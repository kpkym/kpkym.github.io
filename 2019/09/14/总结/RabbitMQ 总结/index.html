<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>RabbitMQ 总结 | kpkym&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="为什么要使用消息队列  异步处理 系统解耦  1 一些概念梳理 Server：又称为Broker。接收客户端连接，实现AMQP的服务器实体。 Connection：连接，应用程序与Broker的网络连接。 Channel：信道，几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道。客户端可建立多个Channel，每个Channel代表一个会话任务。 Message：消息。服务">
<meta name="keywords" content="总结">
<meta property="og:type" content="article">
<meta property="og:title" content="RabbitMQ 总结">
<meta property="og:url" content="https://github.com/kpkym/2019/09/14/总结/RabbitMQ 总结/index.html">
<meta property="og:site_name" content="kpkym&#39;s blog">
<meta property="og:description" content="为什么要使用消息队列  异步处理 系统解耦  1 一些概念梳理 Server：又称为Broker。接收客户端连接，实现AMQP的服务器实体。 Connection：连接，应用程序与Broker的网络连接。 Channel：信道，几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道。客户端可建立多个Channel，每个Channel代表一个会话任务。 Message：消息。服务">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5225109-46b106ffc590da68.png?imageMogr2/auto-orient/strip|imageView2/2/w/1136/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5225109-84e0b04b2dac1efd.png?imageMogr2/auto-orient/strip|imageView2/2/w/1159/format/webp">
<meta property="og:updated_time" content="2021-01-26T02:18:25.522Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RabbitMQ 总结">
<meta name="twitter:description" content="为什么要使用消息队列  异步处理 系统解耦  1 一些概念梳理 Server：又称为Broker。接收客户端连接，实现AMQP的服务器实体。 Connection：连接，应用程序与Broker的网络连接。 Channel：信道，几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道。客户端可建立多个Channel，每个Channel代表一个会话任务。 Message：消息。服务">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/5225109-46b106ffc590da68.png?imageMogr2/auto-orient/strip|imageView2/2/w/1136/format/webp">
  
    <link rel="alternate" href="/atom.xml" title="kpkym&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">kpkym&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/kpkym"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-总结/RabbitMQ 总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/14/总结/RabbitMQ 总结/" class="article-date">
  <time datetime="2019-09-14T05:17:57.000Z" itemprop="datePublished">2019-09-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/中间件/">中间件</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      RabbitMQ 总结
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>为什么要使用消息队列</p>
<ol>
<li>异步处理</li>
<li>系统解耦</li>
</ol>
<h1 id="1-一些概念梳理"><a href="#1-一些概念梳理" class="headerlink" title="1 一些概念梳理"></a>1 一些概念梳理</h1><ul>
<li>Server：又称为Broker。接收客户端连接，实现AMQP的服务器实体。</li>
<li>Connection：连接，应用程序与Broker的网络连接。</li>
<li>Channel：信道，几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道。客户端可建立多个Channel，每个Channel代表一个会话任务。</li>
<li>Message：消息。服务器和应用程序之间传递的数据，本质上就是一段数据，由Properties和Body组成。</li>
<li>Exchange：交换机。接收消息，根据路由键转发消息到绑定的队列。</li>
<li>Binding：Exchange和Queue之间的虚拟连接，binding中可以包含routing key。</li>
<li>Routing key：一个虚拟地址，虚拟机可用它来确定如何路由一个特定消息。</li>
<li>Queue：也称为Message Queue，消息队列，保存消息并将它们转发给消费者。</li>
<li>Virtual Host：其实是一个虚拟概念。类似于权限控制组，一个Virtual Host里面可以有若干个Exchange和Queue，可以用来隔离Exchange和Queue。，同一个Virtual Host里面不能有相同名称的Exchange和Queue。但是权限控制的最小粒度是Virtual Host。（下面会讲到）</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5225109-46b106ffc590da68.png?imageMogr2/auto-orient/strip|imageView2/2/w/1136/format/webp" alt></p>
<p>总结：</p>
<blockquote>
<p>生产者将消息发送到Exchange交换机的，不是发送到Queue上的，生产者不知道消息是谁消费，有哪些消费者消费。Exchange根据一定的路由规则将消息转发到Queue。<br>消费者是监听队列的，不知道是哪个生产者发送的。</p>
</blockquote>
<p>AMQP我的理解</p>
<blockquote>
<p>一个开放的面向消息中间件的协议，所有此协议的实现可以进行互相操作，无论实现语言如何，任何符合此协议的数据格式的消息工具都可以与任何其他兼容工具进行互操作。而以前JMS（Java Message Service），将不同的中间件的实现进行API层次的标准化。</p>
</blockquote>
<h1 id="2-四种类型Exchange"><a href="#2-四种类型Exchange" class="headerlink" title="2 四种类型Exchange"></a>2 四种类型Exchange</h1><p><img src="https://upload-images.jianshu.io/upload_images/5225109-84e0b04b2dac1efd.png?imageMogr2/auto-orient/strip|imageView2/2/w/1159/format/webp" alt><br>自己说说Exchange在RabbitMQ消息中间件中的作用：<br>服务器发送消息不会直接发送到队列中（Queue），而是直接发送给交换机（Exchange），然后根据确定的规则，RabbitMQ将会决定消息该投递到哪个队列。这些规则称为路由键（routing key），队列通过路由键绑定到交换机上。消息发送到服务器端（broker），消息也有自己的路由键（也可以是空），RabbitMQ也会将消息和消息指定发送的交换机的绑定（binding，就是队列和交互机的根据路由键映射的关系）的路由键进行匹配。如果匹配的话，就会将消息投递到相应的队列。</p>
<p>Exchange的类型主要有四种，分别是</p>
<ol>
<li>Direct Exchange：将消息中的Routing key与该Exchange关联的所有Binding中的Routing key进行比较，如果相等，则发送到该Binding对应的Queue中。</li>
<li>Topic Exchange：将消息中的Routing key与该Exchange关联的所有Binding中的Routing key进行对比，如果匹配上了，则发送到该Binding对应的Queue中。</li>
<li>Fanout Exchange：直接将消息转发到所有binding的对应queue中，这种exchange在路由转发的时候，忽略Routing key。</li>
<li>Headers Exchange：将消息中的headers与该Exchange相关联的所有Binging中的参数进行匹配，如果匹配上了，则发送到该Binding对应的Queue中。</li>
</ol>
<ul>
<li>Direct Exchange<blockquote>
<p>将消息中的Routing key与该Exchange关联的所有Binding中的Routing key进行比较，如果相等，则发送到该Binding对应的Queue中。<br>一个Exchange可以Binding一个或多个Queue。<br>绑定可以指定Routing key，Binding的多个Queue可以使用相同的Routing key，也可以使用不同的Routing key。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>特别的Exchange<br>默认的Exchange（名字为空，AMQP default）</p>
</blockquote>
<blockquote>
<p>默认的Exchange不能进行Binding操作<br>任何发送到该Exchange的消息都会被转发到Routing key指定的Queue中<br>如果vhost中不存在Routing key中指定的队列名，则该消息会被抛弃。</p>
</blockquote>
<ul>
<li>Topic Exchange<blockquote>
<p>将消息中的Routing key与该Exchange关联的所有Binding中的Routing key进行对比，如果匹配上了，则发送到该Binding对应的Queue中。</p>
<p>匹配规则<br>* 匹配一个单词<br># 匹配0个或多个字符<br>*，# 只能写在.号左右，且不能挨着字符<br>单词和单词之间需要用.隔开。</p>
</blockquote>
</li>
</ul>
<blockquote>
<blockquote>
<p>如果指定了Exchange是Topic类型的，但是相应的Binding中的Routing key *，#都没有，则相等才转发，类似于Direct Exchange<br>如果Binding中的Routing key为#或者#.#,则全部转发，类似Fanout Exchange</p>
</blockquote>
</blockquote>
<ul>
<li>Fanout Exchange<blockquote>
<p>直接将消息转发到所有binding的对应queue中，这种exchange在路由转发的时候，忽略Routing key。</p>
<blockquote>
<p>Fanout Exchange这种exchange效率最高，fanout &gt; direct &gt; topic</p>
</blockquote>
</blockquote>
</li>
</ul>
<p><strong>将消息中的headers与该Exchange相关联的所有Binging中的参数进行匹配，如果匹配上了，则发送到该Binding对应的Queue中。</strong></p>
<p>匹配规则：</p>
<ol>
<li>如果Binding中的</li>
<li>x-match = all：表示所有的键值对都匹配才能转发到消息。</li>
<li>x-match = any: 表示只要有键值对匹配就能转发消息。</li>
</ol>
<p>注意：</p>
<ol>
<li>Binging的时候，至少需要指定两个参数，其中的一个是x-match = all或x-match = any。</li>
<li>Binging的时候，不需要指定Routing key</li>
<li>发送消息的时候，不需要指定Routing key</li>
<li>转发消息的时候，忽略Routing key</li>
<li>如果是x-match = all则发送的headers不能比bingding的参数少，否则匹配不上。</li>
</ol>
<h1 id="3-Binding-Queue-Message概念"><a href="#3-Binding-Queue-Message概念" class="headerlink" title="3 Binding,Queue,Message概念"></a>3 Binding,Queue,Message概念</h1><p><strong>Binding</strong></p>
<ol>
<li>default Exchange不能进行Binding,也不需要进行绑定。</li>
<li>除default Exchange之外，其他任何Exchange都需要和Queue进行Binding，否则无法进行消息路由（转发）</li>
<li>Binding的时候，可以设置一个或多个参数，其中参数要特别注意参数类型，如果Routing key中指定的参数类型和消息中指定的参数类型不一致（header Exchange）也不能进行消息转发。</li>
<li>Direct Exchange，Topic Exchange进行Binding的时候，需要指定Routing key</li>
<li>Fanout Exchange，Headers Exchange进行Binding的时候，不需要指定Routing key。</li>
</ol>
<p><strong>Queue</strong></p>
<p>属性</p>
<ol>
<li>Durability：是否持久化，Durable是，Transient是否。如果不持久化，那么在服务器宕机或重启之后Queue就会丢失。</li>
<li>Auto delete：如果选择yes，当最后一个消费者不在监听Queue的时候，该Queue就会自动删除，一般选择false。</li>
<li>Arguments：AMQP协议留给AMQP实现者扩展使用的。<ol>
<li>x-message-ttl：一个消息推送到队列中的存活时间。设置的值之后还没消费就会被删除。</li>
<li>x-expires：在自动删除该队列的时候，可以使用该队列的时间。</li>
<li>x-max-length：在队列头部删除元素之前，队列可以包含多少个（就绪）消息，如果再次向队列中发送消息，会删除最早的那条消息，用来控制队列中消息的数量。</li>
<li>x-max-length-bytes：在队列头部删除元素之前，队列的总消息体的大小，用来控制队列中消息的总大小。</li>
<li>x-dead-letter-exchange：当消息被拒绝或者消息过期，消息重新发送到的交换机（Exchange）的可选名称。</li>
<li>x-dead-letter-routing-key：当消息被拒绝或者消息过期，消息重新发送到的交换机绑定的Route key的名称，如果没有设置则使用之前的Route key。</li>
<li>x-max-priority：队列支持的最大优先级数，如果没有设置则不支持消息优先级</li>
<li>x-queue-mode：将队列设置为延迟模式，在磁盘上保留尽可能多的消息以减少RAM使用; 如果未设置，队列将保持在内存中的缓存，以尽可能快地传递消息。</li>
<li>x-queue-master-locator：将队列设置为主位置模式，确定在节点集群上声明队列主节点所在的规则。</li>
</ol>
</li>
</ol>
<p><strong>Message概念</strong></p>
<p>消息。服务器和应用程序之间传送的数据，本质上就是一段数据，由Properties和Payload(body)组成。</p>
<ol>
<li>Delivery mode：是否持久化，如果未设置持久化，转发到queue中并未消费则重启服务或者服务宕机则消息丢失。</li>
<li>Headers：头信息，是由一个或多个健值对组成的，当固定的Properties不满足我们需要的时候，可以自己扩展。</li>
<li>Properties（属性）<ol>
<li>content_type：传输协议</li>
<li>content_encoding：编码方式</li>
<li>priority：优先级</li>
<li>correlation_id：rpc属性，请求的唯一标识。</li>
<li>reply_to：rpc属性，</li>
<li>expiration：消息的过期时间</li>
<li>message_id：消息的id</li>
<li>timestamp：消息的时间戳<br>…</li>
</ol>
</li>
</ol>
<p><strong>如何保证消息的不丢失，三个地方做到持久化。</strong></p>
<ul>
<li>Exchange需要持久化。</li>
<li>Queue需要持久化。</li>
<li>Message需要持久化。</li>
</ul>
<p><strong>通道和并发注意事项（线程安全）</strong></p>
<blockquote>
<p>根据经验，在线程间共享Channel（通道）是要避免的。应用应该优先使用每个线程自己的Channel（通道）实例，而不是多个线程共享这个Channel（通道）实例。</p>
</blockquote>
<blockquote>
<p>虽然有些在Channel（通道）上的操作是可以并发安全的调用，但是一些操作不行会导致一些边界交错，双重确认等等。</p>
</blockquote>
<blockquote>
<p>在共享（多线程）Channel（通道）上进行并发发布会导致一些边界交错，触发连接协议异常和连接关闭。因此需要严格在应用中同步调用（Channel#basicPublish必须在正确关键的地方调用）。线程之间的共享也会干扰生产者的消息确认。我们强烈的推荐不应该在通道上进行并发的发布消息。</p>
</blockquote>
<blockquote>
<p>在共享的Channel（通道）上一个线程生产（publish）消息，一个线程消费（consume）消息是线程安全的。</p>
</blockquote>
<blockquote>
<p>服务器推送可以同时发送，保证每通道的订阅被保留。 调度机制使用java.util.concurrent.ExecutorService。 可以使用单列的ConnectionFactory调用ConnectionFactory#setSharedExecutor去设置所有连接共用的executor。</p>
</blockquote>
<blockquote>
<p>当我们手动确认manual acknowledgements 的时候，很重要的是考虑什么线程去做这个ack确认。如果接收传递的线程（例如，Consumer＃handleDelivery委托给不同线程的传递处理）不同于手动确认的线程，则将多个线程参数设置为true是线程不安全的并导致双重确认，因此导致通道协议异常导致Channel关闭。一次确认一条消息可以确保安全的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过ConnectionFactory获得Connection，Connection得到Channel</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"192.168.1.131"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">"zhihao.miao"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line"></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建exchange，类型是direct类型</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">"zhihao.miao"</span>,<span class="string">"direct"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建exchange，类型是direct类型</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">"zhihao.miao.info"</span>, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三个参数表示是否持久化，同步操作，有返回值</span></span><br><span class="line">        AMQP.Exchange.DeclareOk ok = channel.exchangeDeclare(<span class="string">"zhihao.miao.debug"</span>,BuiltinExchangeType.DIRECT,<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(ok);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置属性</span></span><br><span class="line">        Map&lt;String,Object&gt; argument = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        argument.put(<span class="string">"alternate-exchange"</span>,<span class="string">"log"</span>);</span><br><span class="line">        channel.exchangeDeclare(<span class="string">"zhihao.miao.warn"</span>,BuiltinExchangeType.TOPIC,<span class="keyword">true</span>,<span class="keyword">false</span>,argument);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//异步创建exchange，没有返回值</span></span><br><span class="line">        channel.exchangeDeclareNoWait(<span class="string">"zhihao.miao.log"</span>,BuiltinExchangeType.TOPIC,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,argument);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断exchange是否存在,存在的返回ok，不存在的exchange则报错</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        AMQP.Exchange.DeclareOk declareOk = channel.exchangeDeclarePassive("zhihao.miao.info");</span></span><br><span class="line"><span class="comment">        System.out.println(declareOk);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        declareOk = channel.exchangeDeclarePassive("zhihao.miao.info2");</span></span><br><span class="line"><span class="comment">        System.out.println(declareOk);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除exchange(可重复执行），删除一个不存在的也不会报错</span></span><br><span class="line">        channel.exchangeDelete(<span class="string">"zhihao.miao"</span>);</span><br><span class="line">        channel.exchangeDelete(<span class="string">"zhihao.miao.debug"</span>);</span><br><span class="line">        channel.exchangeDelete(<span class="string">"zhihao.miao.info"</span>);</span><br><span class="line">        channel.exchangeDelete(<span class="string">"zhihao.miao.warn"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除exchange</span></span><br><span class="line">        channel.exchangeDelete(<span class="string">"zhihao.miao.log"</span>);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列的api操作。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"192.168.1.131"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">"zhihao.miao"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line"></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二个参数表示是否持久化，第三个参数是判断这个队列是否在连接是否生效，为true表示连接关闭队列删除。</span></span><br><span class="line">        AMQP.Queue.DeclareOk ok = channel.queueDeclare(<span class="string">"zhihao.info"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(ok);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//异步没有返回值的方法api</span></span><br><span class="line">        channel.queueDeclareNoWait(<span class="string">"zhihao.info.miao"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断queue是否存在，不存在会抛出异常</span></span><br><span class="line">        <span class="comment">//channel.exchangeDeclarePassive("zhihao.info");</span></span><br><span class="line">        <span class="comment">//抛出错误</span></span><br><span class="line">        <span class="comment">//channel.exchangeDeclarePassive("zhihao.info.miao2");</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//exchange和queue进行绑定（可重复执行，不会重复创建）</span></span><br><span class="line">        channel.queueBind(<span class="string">"zhihao.info"</span>,<span class="string">"zhihao.miao.order"</span>,<span class="string">"info"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//异步进行绑定</span></span><br><span class="line">        channel.queueBindNoWait(<span class="string">"zhihao.info.miao"</span>,<span class="string">"zhihao.miao.pay"</span>,<span class="string">"info"</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//exchange与exchange进行绑定(可重复执行，不会重复创建）</span></span><br><span class="line">        channel.exchangeBind(<span class="string">"zhihao.miao.email"</span>,<span class="string">"zhihao.miao.weixin"</span>,<span class="string">"debug"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//exchange和queue进行解绑（可重复执行）</span></span><br><span class="line">        channel.queueUnbind(<span class="string">"zhihao.info"</span>,<span class="string">"zhihao.miao.order"</span>,<span class="string">"info"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//exchange和exchange进行解绑（可重复执行）</span></span><br><span class="line">        channel.exchangeUnbind(<span class="string">"zhihao.info.miao"</span>,<span class="string">"zhihao.miao.pay"</span>,<span class="string">"debug"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除队列</span></span><br><span class="line">        channel.queueDelete(<span class="string">"zhihao.info"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息的发送：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setUri(<span class="string">"amqp://zhihao.miao:123456@192.168.1.131:5672"</span>);</span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line"></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder().deliveryMode(<span class="number">2</span>).</span><br><span class="line">                contentEncoding(<span class="string">"UTF-8"</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个参数是exchange参数，如果是为空字符串，那么就会发送到(AMQP default)默认的exchange，而且routingKey</span></span><br><span class="line">        <span class="comment">//便是所要发送到的队列名</span></span><br><span class="line">        channel.basicPublish(<span class="string">""</span>,<span class="string">"zhihao.info.miao"</span>,properties,<span class="string">"忘记密码，验证码是1234"</span>.getBytes());</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>,<span class="string">"zhihao.miao"</span>,properties,<span class="string">"忘记密码，六位验证密码是343sdf"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//direct类型的exchange类型的exchange，zhihao.miao.order绑定zhihao.info.miao队列，route key是order</span></span><br><span class="line">        channel.basicPublish(<span class="string">"zhihao.miao.order"</span>,<span class="string">"order"</span>,properties,<span class="string">"爱奇艺会员到期了"</span>.getBytes());</span><br><span class="line">        <span class="comment">//zhihao.miao.pay绑定zhihao.info.miao队列，route key是order</span></span><br><span class="line">        channel.basicPublish(<span class="string">"zhihao.miao.pay"</span>,<span class="string">"pay"</span>,properties,<span class="string">"优酷会员到期了"</span>.getBytes());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//topic类型的exchange</span></span><br><span class="line">        channel.basicPublish(<span class="string">"log"</span>,<span class="string">"user.log"</span>,properties,<span class="string">"你的外卖已经送达"</span>.getBytes());</span><br><span class="line">        channel.basicPublish(<span class="string">"log"</span>,<span class="string">"user.log.info"</span>,properties,<span class="string">"你的外卖正在配送中"</span>.getBytes());</span><br><span class="line">        channel.basicPublish(<span class="string">"log"</span>,<span class="string">"user"</span>,properties,<span class="string">"你的投诉已经采纳"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息消费：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"192.168.1.131"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">"zhihao.miao"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户端的消费消息</span></span><br><span class="line">        Map&lt;String,Object&gt; clientProperties = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        clientProperties.put(<span class="string">"desc"</span>,<span class="string">"支付系统2.0"</span>);</span><br><span class="line">        clientProperties.put(<span class="string">"author"</span>,<span class="string">"zhihao.miao"</span>);</span><br><span class="line">        clientProperties.put(<span class="string">"user"</span>,<span class="string">"zhihao.miao@xxx.com"</span>);</span><br><span class="line"></span><br><span class="line">        connectionFactory.setClientProperties(clientProperties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给客户端的connetction命名</span></span><br><span class="line">        Connection connection = connectionFactory.newConnection(<span class="string">"log队列的消费者"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给channel起个编号</span></span><br><span class="line">        Channel channel = connection.createChannel(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回consumerTag，也可以通过重载方法进行设置consumerTag</span></span><br><span class="line">        String consumerTag = channel.basicConsume(<span class="string">"user_log_queue"</span>,<span class="keyword">true</span>,<span class="keyword">new</span> SimpleConsumer(channel));</span><br><span class="line">        System.out.println(consumerTag);</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的消息逻辑，继承DefaultConsumer类重写handleDelivery方法，如果是手工确认消息，会在handleDelivery方法中进行相关的确认（调用相关api）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleConsumer</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleConsumer</span><span class="params">(Channel channel)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(consumerTag);</span><br><span class="line">        System.out.println(<span class="string">"-----收到消息了---------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"消息属性为："</span>+properties);</span><br><span class="line">        System.out.println(<span class="string">"消息内容为："</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-Spring-AMQP简介与quick-start"><a href="#4-Spring-AMQP简介与quick-start" class="headerlink" title="4 Spring AMQP简介与quick start"></a>4 Spring AMQP简介与quick start</h1><p>Spring AMQP包括两个部分；spring-amqp是对amqp的一些概念的一些抽象。spring-rabbit是对AMQP的实现RabbitMQ的实现。</p>
<p>特征</p>
<ol>
<li>异步处理消费消息的一个监听容器（Listener container）</li>
<li>使用RabbitTemplate类的实例来发送和接收消息。</li>
<li>使用RabbitAdmin去自动声明队列（queues），交换机（exchanges），绑定（bindings）</li>
<li>spring-amqp模块是对AMQP协议的一个抽象和封装。所以说对所有的AMQP的实现都进行的抽象和封装，比如<br>org.springframework.amqp.core.Binding：绑定的封装，类型有QUEUE和EXCHANGE。<br>org.springframework.amqp.core.Exchange：其有基本的四种实现</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一次性生成多个queue，exchange,binding</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeclareConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Queue&gt; <span class="title">queues</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Queue&gt; queueList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        queueList.add(<span class="keyword">new</span> Queue(<span class="string">"chao.wang.debug"</span>,<span class="keyword">true</span>));</span><br><span class="line">        queueList.add(<span class="keyword">new</span> Queue(<span class="string">"chao.wang.info"</span>,<span class="keyword">true</span>));</span><br><span class="line">        queueList.add(<span class="keyword">new</span> Queue(<span class="string">"chao.wang.error"</span>,<span class="keyword">true</span>));</span><br><span class="line">        <span class="keyword">return</span> queueList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Exchange&gt; <span class="title">exchanges</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Exchange&gt; exchangeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        exchangeList.add(<span class="keyword">new</span> TopicExchange(<span class="string">"chao.wang.debug.topic.exchange"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>));</span><br><span class="line">        exchangeList.add(<span class="keyword">new</span> TopicExchange(<span class="string">"chao.wang.info.topic.exchange"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>));</span><br><span class="line">        exchangeList.add(<span class="keyword">new</span> TopicExchange(<span class="string">"chao.wang.error.topic.exchange"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>));</span><br><span class="line">        <span class="keyword">return</span> exchangeList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Binding&gt; <span class="title">bindings</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Binding&gt; bindingList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        bindingList.add(BindingBuilder.bind(<span class="keyword">new</span> Queue(<span class="string">"chao.wang.debug"</span>)).</span><br><span class="line">                to(<span class="keyword">new</span> TopicExchange(<span class="string">"chao.wang.debug.topic.exchange"</span>)).with(<span class="string">"chao.wang.#"</span>));</span><br><span class="line">        bindingList.add(BindingBuilder.bind(<span class="keyword">new</span> Queue(<span class="string">"chao.wang.info"</span>)).</span><br><span class="line">                to(<span class="keyword">new</span> TopicExchange(<span class="string">"chao.wang.debug.topic.exchange"</span>)).with(<span class="string">"chao.wang.*"</span>));</span><br><span class="line">        bindingList.add(BindingBuilder.bind(<span class="keyword">new</span> Queue(<span class="string">"chao.wang.error"</span>)).</span><br><span class="line">                to(<span class="keyword">new</span> TopicExchange(<span class="string">"chao.wang.debug.topic.exchange"</span>)).with(<span class="string">"chao.wang.error.*"</span>));</span><br><span class="line">        <span class="keyword">return</span> bindingList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自动声明的一些条件</p>
<ul>
<li>要有连接（对rabbitmq的连接）</li>
<li>容器中要有org.springframework.amqp.rabbit.core.RabbitAdmin的实例</li>
<li>RabbitAdmin的autoStartup属性必须为true。</li>
<li>如果ConnectionFactory使用的是CachingConnectionFactory，则cacheMode必须是CachingConnectionFactory.CacheMode.CHANNEL（默认）。</li>
<li>所要声明的组件(Queue，Exchange和Binding)的shouldDeclare必须是true（默认就是true）</li>
<li>Queue队列的名字不能以amq.开头。<blockquote>
<p>注意：Queue，Exchange和Binding都直接或者间接的继承Declarable，而Declarable中定义了shouldDeclare的方法。</p>
</blockquote>
</li>
</ul>
<p>SimpleMessageListenerContainer更多用法 <a href="https://www.jianshu.com/p/213827ebc08c" target="_blank" rel="noopener">SimpleMessageListenerContainer更多用法</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">messageListenerContainer</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">        SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">        container.setConnectionFactory(connectionFactory);</span><br><span class="line">        container.setQueueNames(<span class="string">"order"</span>,<span class="string">"pay"</span>,<span class="string">"zhihao.miao.order"</span>);</span><br><span class="line"></span><br><span class="line">        MessageListenerAdapter adapter = <span class="keyword">new</span> MessageListenerAdapter(<span class="keyword">new</span> MessageHandler());</span><br><span class="line">        <span class="comment">//设置处理器的消费消息的默认方法,如果没有设置，那么默认的处理器中的默认方式是handleMessage方法</span></span><br><span class="line">        adapter.setDefaultListenerMethod(<span class="string">"onMessage"</span>);</span><br><span class="line">        Map&lt;String, String&gt; queueOrTagToMethodName = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        queueOrTagToMethodName.put(<span class="string">"order"</span>,<span class="string">"onorder"</span>);</span><br><span class="line">        queueOrTagToMethodName.put(<span class="string">"pay"</span>,<span class="string">"onpay"</span>);</span><br><span class="line">        queueOrTagToMethodName.put(<span class="string">"zhihao.miao.order"</span>,<span class="string">"oninfo"</span>);</span><br><span class="line">        adapter.setQueueOrTagToMethodName(queueOrTagToMethodName);</span><br><span class="line">        container.setMessageListener(adapter);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MessageListenerAdapter</span></span><br><span class="line"><span class="comment">// 1.可以把一个没有实现MessageListener和ChannelAwareMessageListener接口的类适配成一个可以处理消息的处理器</span></span><br><span class="line"><span class="comment">// 2.默认的方法名称为：handleMessage，可以通过setDefaultListenerMethod设置新的消息处理方法</span></span><br><span class="line"><span class="comment">// 3.MessageListenerAdapter支持不同的队列交给不同的方法去执行。使用setQueueOrTagToMethodName方法设置，当根据queue名称没有找到匹配的方法的时候，就会交给默认的方法去处理。</span></span><br></pre></td></tr></table></figure>
<p>MessageConverter</p>
<p>源码分析总结：</p>
<ol>
<li>MessageConverter可以把java对象转换成Message对象，也可以把Message对象转换成java对象</li>
<li>MessageListenerAdapter内部通过MessageConverter把Message转换成java对象，然后找到相应的处理方法，参数为转换成的java对象。</li>
<li>SimpleMessageConverter处理逻辑：<ol>
<li>如果content_type是以text开头，则把消息转换成String类型</li>
<li>如果content_type的值是application/x-java-serialized-object则把消息序列化为java对象，否则，把消息转换成字节数组。</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendOrder</span><span class="params">( RabbitTemplate rabbitTemplate)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        order.setId(<span class="number">1</span>);</span><br><span class="line">        order.setUserId(<span class="number">1000</span>);</span><br><span class="line">        order.setAmout(<span class="number">88</span>d);</span><br><span class="line">        order.setTime(LocalDateTime.now().toString());</span><br><span class="line"></span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        String json = mapper.writeValueAsString(order);</span><br><span class="line">        System.out.println(json);</span><br><span class="line"></span><br><span class="line">        MessageProperties messageProperties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">        messageProperties.setContentType(<span class="string">"application/json"</span>);</span><br><span class="line">        <span class="comment">//指定的__TypeId__属性值必须是消费端的Order的全类名，如果不匹配则会报错。</span></span><br><span class="line">        messageProperties.getHeaders().put(<span class="string">"__TypeId__"</span>,<span class="string">"com.zhihao.miao.test.day10.Sender.Order"</span>);</span><br><span class="line">        Message message = <span class="keyword">new</span> Message(json.getBytes(),messageProperties);</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.send(<span class="string">""</span>,<span class="string">"zhihao.miao.order"</span>,message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(Application.class);</span><br><span class="line">        RabbitTemplate rabbitTemplate = context.getBean(RabbitTemplate.class);</span><br><span class="line">        System.out.println(rabbitTemplate);</span><br><span class="line">        sendOrder(rabbitTemplate);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================================================================================================</span></span><br><span class="line"><span class="comment">// 在jackson2JsonMessageConverter转换器中指定映射配置</span></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">messageListenerContainer</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">        SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">        container.setConnectionFactory(connectionFactory);</span><br><span class="line">        container.setQueueNames(<span class="string">"zhihao.miao.order"</span>);</span><br><span class="line"></span><br><span class="line">        MessageListenerAdapter adapter = <span class="keyword">new</span> MessageListenerAdapter(<span class="keyword">new</span> MessageHandler());</span><br><span class="line">        <span class="comment">//指定Json转换器</span></span><br><span class="line">        Jackson2JsonMessageConverter jackson2JsonMessageConverter =<span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费端配置映射</span></span><br><span class="line">        Map&lt;String, Class&lt;?&gt;&gt; idClassMapping = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        idClassMapping.put(<span class="string">"order"</span>,Order.class);</span><br><span class="line">        idClassMapping.put(<span class="string">"user"</span>,User.class);</span><br><span class="line"></span><br><span class="line">        DefaultJackson2JavaTypeMapper jackson2JavaTypeMapper = <span class="keyword">new</span> DefaultJackson2JavaTypeMapper();</span><br><span class="line">        jackson2JavaTypeMapper.setIdClassMapping(idClassMapping);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"在jackson2JsonMessageConverter转换器中指定映射配置"</span>);</span><br><span class="line">        jackson2JsonMessageConverter.setJavaTypeMapper(jackson2JavaTypeMapper);</span><br><span class="line">        adapter.setMessageConverter(jackson2JsonMessageConverter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置处理器的消费消息的默认方法</span></span><br><span class="line">        adapter.setDefaultListenerMethod(<span class="string">"onMessage"</span>);</span><br><span class="line">        container.setMessageListener(adapter);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后在生产端就可以指定对应的key，而不需要再去指定全类名了，</span></span><br><span class="line">MessageProperties messageProperties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">messageProperties.setContentType(<span class="string">"application/json"</span>);</span><br><span class="line">messageProperties.getHeaders().put(<span class="string">"__TypeId__"</span>,<span class="string">"order"</span>);</span><br><span class="line">Message message = <span class="keyword">new</span> Message(json.getBytes(),messageProperties);</span><br><span class="line"></span><br><span class="line"><span class="comment">// List</span></span><br><span class="line">MessageProperties messageProperties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">messageProperties.setContentType(<span class="string">"application/json"</span>);</span><br><span class="line">messageProperties.getHeaders().put(<span class="string">"__TypeId__"</span>,<span class="string">"java.util.List"</span>);</span><br><span class="line">messageProperties.getHeaders().put(<span class="string">"__ContentTypeId__"</span>,<span class="string">"order"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line">MessageProperties messageProperties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">messageProperties.setContentType(<span class="string">"application/json"</span>);</span><br><span class="line">messageProperties.getHeaders().put(<span class="string">"__TypeId__"</span>,<span class="string">"java.util.Map"</span>);</span><br><span class="line">messageProperties.getHeaders().put(<span class="string">"__KeyTypeId__"</span>,<span class="string">"java.lang.String"</span>);</span><br><span class="line">messageProperties.getHeaders().put(<span class="string">"__ContentTypeId__"</span>,<span class="string">"order"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// public void onMessage(List&lt;Order&gt; orders)&#123;</span></span><br><span class="line"><span class="comment">//     System.out.println("---------onMessage---List&lt;Order&gt;-------------");</span></span><br><span class="line"><span class="comment">//     orders.stream().forEach(order -&gt; System.out.println(order));</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// public void onMessage(Map&lt;String,Object&gt; orderMaps)&#123;</span></span><br><span class="line"><span class="comment">//     System.out.println("-------onMessage---Map&lt;String,Object&gt;------------");</span></span><br><span class="line"><span class="comment">//     orderMaps.keySet().forEach(key -&gt; System.out.println(orderMaps.get(key)));</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>结论</strong></p>
<blockquote>
<p>如果生产者发送的是list的json数据，则还需要增加一个<strong>ContentTypeId</strong>的header，用于指明List里面的具体对象。</p>
</blockquote>
<blockquote>
<p>如果生产者发送的是map的json数据，则需要指定<strong>KeyTypeId</strong>，<strong>ContentTypeId</strong>的header，用于指明map里面的key，value的具体对象。</p>
</blockquote>
<blockquote>
<p>ContentTypeDelegatingMessageConverter详解</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// MessageProperties messageProperties = new MessageProperties();</span></span><br><span class="line"><span class="comment">// messageProperties.setContentType("text/plain");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MessageProperties messageProperties = new MessageProperties();</span></span><br><span class="line"><span class="comment">// messageProperties.setContentType("image/jepg");</span></span><br><span class="line"></span><br><span class="line">TextMessageConverter textMessageConverter = <span class="keyword">new</span> TextMessageConverter();</span><br><span class="line"></span><br><span class="line">ContentTypeDelegatingMessageConverter contentTypeDelegatingMessageConverter = <span class="keyword">new</span> ContentTypeDelegatingMessageConverter();</span><br><span class="line">contentTypeDelegatingMessageConverter.addDelegate(<span class="string">"text"</span>,textMessageConverter);</span><br><span class="line">contentTypeDelegatingMessageConverter.addDelegate(<span class="string">"html/text"</span>,textMessageConverter);</span><br><span class="line">contentTypeDelegatingMessageConverter.addDelegate(<span class="string">"xml/text"</span>,textMessageConverter);</span><br><span class="line">contentTypeDelegatingMessageConverter.addDelegate(<span class="string">"text/plain"</span>,textMessageConverter);</span><br><span class="line"></span><br><span class="line">contentTypeDelegatingMessageConverter.addDelegate(<span class="string">"json"</span>,jackson2JsonMessageConverter);</span><br><span class="line">contentTypeDelegatingMessageConverter.addDelegate(<span class="string">"application/json"</span>,jackson2JsonMessageConverter);</span><br><span class="line"></span><br><span class="line">contentTypeDelegatingMessageConverter.addDelegate(<span class="string">"image/jpg"</span>,<span class="keyword">new</span> JPGMessageConverter());</span><br><span class="line">contentTypeDelegatingMessageConverter.addDelegate(<span class="string">"image/jepg"</span>,<span class="keyword">new</span> JPGMessageConverter());</span><br><span class="line">contentTypeDelegatingMessageConverter.addDelegate(<span class="string">"image/png"</span>,<span class="keyword">new</span> JPGMessageConverter());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">adapter.setMessageConverter(contentTypeDelegatingMessageConverter);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结论：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ContentTypeDelegatingMessageConverter是一个代理的MessageConverter。</span></span><br><span class="line"><span class="comment">// ContentTypeDelegatingMessageConverter本身不做消息转换的具体动作，而是将消息转换委托给具体的MessageConverter。我们可以设置COntentType和MessageConverter的映射关系。</span></span><br><span class="line"><span class="comment">// ContentTypeDelegatingMessageConverter还有一个默认的MessageConverter，也就是说当根据ContentType没有找到映射的MessageConverter的时候，就会使用默认的MessageConverter。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RabbitListenerConfigurer</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">connectionFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CachingConnectionFactory factory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">        factory.setUri(<span class="string">"amqp://zhihao.miao:123456@192.168.1.131:5672"</span>);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RabbitListenerContainerFactory&lt;?&gt; rabbitListenerContainerFactory(ConnectionFactory connectionFactory)&#123;</span><br><span class="line">        SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">        factory.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RabbitListenerConfigurer <span class="title">rabbitListenerConfigurer</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RabbitListenerConfigurer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureRabbitListeners</span><span class="params">(RabbitListenerEndpointRegistrar registrar)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//endpoint设置zhihao.miao.order队列的消息处理逻辑</span></span><br><span class="line">                SimpleRabbitListenerEndpoint endpoint = <span class="keyword">new</span> SimpleRabbitListenerEndpoint();</span><br><span class="line">                endpoint.setId(<span class="string">"10"</span>);</span><br><span class="line">                endpoint.setQueueNames(<span class="string">"zhihao.miao.order"</span>);</span><br><span class="line">                endpoint.setMessageListener(message -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">"endpoint1处理消息的逻辑"</span>);</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">//使用适配器来处理消息，设置了order，pay队列的消息处理逻辑</span></span><br><span class="line">                SimpleRabbitListenerEndpoint endpoint2 = <span class="keyword">new</span> SimpleRabbitListenerEndpoint();</span><br><span class="line">                endpoint2.setId(<span class="string">"11"</span>);</span><br><span class="line">                endpoint2.setQueueNames(<span class="string">"order"</span>,<span class="string">"pay"</span>);</span><br><span class="line">                System.out.println(<span class="string">"endpoint2处理消息的逻辑"</span>);</span><br><span class="line">                endpoint2.setMessageListener(<span class="keyword">new</span> MessageListenerAdapter(<span class="keyword">new</span> MessageHandler()));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//注册二个endpoint</span></span><br><span class="line">                registrar.registerEndpoint(endpoint);</span><br><span class="line">                registrar.registerEndpoint(endpoint2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<blockquote>
<p>如果消息属性中没有指定content_type，则接收消息的处理方法接收类型是byte[],如果消息属性中指定content_type为text，则接收消息的处理方法的参数类型是String类型。不管有没有指定content_type，处理消息方法的参数类型是Message都不会报错。</p>
</blockquote>
<p><strong>使用@RabbitListener注解消费消息</strong></p>
<p>在启动入口增加@EnableRabbit注解<br>在spring容器中托管一个RabbitListenerContainerFactory的bean（默认的实现是org.springframework.amqp.rabbit.config.SimpleRabbitListenerContainerFactory）<br>写一个消息处理类托管到spring容器中，然后在具体的消息处理方法上增加@RabbitListener注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//支持自动声明绑定，声明之后自动监听队列的队列，此时@RabbitListener注解的queue和bindings不能同时指定，否则报错</span></span><br><span class="line">    <span class="meta">@RabbitListener</span>(bindings =&#123;<span class="meta">@QueueBinding</span>(value = <span class="meta">@Queue</span>(value = <span class="string">"q5"</span>,durable = <span class="string">"true"</span>),</span><br><span class="line">            exchange =<span class="meta">@Exchange</span>(value = <span class="string">"zhihao.miao.exchange"</span>,durable = <span class="string">"true"</span>),key = <span class="string">"welcome"</span>)&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====消费消息"</span>+message.getMessageProperties().getConsumerQueue()+<span class="string">"===handleMessage"</span>);</span><br><span class="line">        System.out.println(message.getMessageProperties());</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认 rabbitListenerContainerFactory</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>@RabbitListener和@RabbitHandler搭配使用</strong></p>
<p>@RabbitListener可以标注在类上面，当使用在类上面的时候，需要配合@RabbitHandler注解一起使用，@RabbitListener标注在类上面表示当有收到消息的时候，就交给带有@RabbitHandler的方法处理，具体找哪个方法处理，需要跟进MessageConverter转换后的java对象。</p>
<p><strong>ReturnListener</strong></p>
<p>设置</p>
<ul>
<li><code>factory.setPublisherReturns(true);</code></li>
<li><code>rabbitTemplate.setMandatory(true);或rabbitTemplate.setMandatoryExpression(new SpelExpressionParser().parseExpression(&quot;(1+2) &gt; 2&quot;)); //表达式的值为true</code><br>才会触发returnCallback回调方法的执行。</li>
</ul>
<p><strong>发送确认（publisher confirms）</strong></p>
<p>RabbitMQ java Client实现发送确认deliveryTag（投递的标识），当Channel设置成confirm模式时，发布的每一条消息都会获得一个唯一的deliveryTag，任何channel上发布的第一条消息的deliveryTag为1，此后的每一条消息都会加1，deliveryTag在channel范围内是唯一的。</p>
<p><strong>消息可靠性的二种方式</strong></p>
<ol>
<li>事务，利用AMQP协议的一部分，发送消息前设置channel为tx模式（channel.txSelect();），如果txCommit提交成功了，则消息一定到达了broker了，如果在txCommit执行之前broker异常崩溃或者由于其他原因抛出异常，这个时候我们便可以捕获异常通过txRollback回滚事务了。（大大得削弱消息中间件的性能）</li>
<li>消息确认（publish confirms），设置管道为confirmSelect模式（channel.confirmSelect();）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Long id = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> TreeSet&lt;Long&gt; tags = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">send</span><span class="params">(Channel channel,<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder().deliveryMode(<span class="number">2</span>).</span><br><span class="line">                contentEncoding(<span class="string">"UTF-8"</span>).build();</span><br><span class="line">        channel.basicPublish(<span class="string">"zhihao.direct.exchange"</span>,<span class="string">"zhihao.miao.order"</span>,properties,bytes);</span><br><span class="line">        <span class="keyword">return</span> ++id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"></span><br><span class="line">        connectionFactory.setUri(<span class="string">"amqp://zhihao.miao:123456@192.168.1.131:5672"</span>);</span><br><span class="line"></span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line"></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是当前的channel处于确认模式</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使当前的channel处于事务模式，与上面的使channel处于确认模式使互斥的</span></span><br><span class="line">        <span class="comment">//channel.txSelect();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * deliveryTag 消息id</span></span><br><span class="line"><span class="comment">         * multiple 是否批量</span></span><br><span class="line"><span class="comment">         *      如果是true，就意味着，小于等于deliveryTag的消息都处理成功了</span></span><br><span class="line"><span class="comment">         *      如果是false，只是成功了deliveryTag这一条消息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.addConfirmListener(<span class="keyword">new</span> ConfirmListener() &#123;</span><br><span class="line">            <span class="comment">//消息发送成功并且在broker落地，deliveryTag是唯一标志符，在channek上发布的消息的deliveryTag都会比之前加1</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAck</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"=========deliveryTag=========="</span>);</span><br><span class="line">                System.out.println(<span class="string">"deliveryTag: "</span>+deliveryTag);</span><br><span class="line">                System.out.println(<span class="string">"multiple: "</span>+multiple);</span><br><span class="line">                <span class="comment">//处理成功发送的消息</span></span><br><span class="line">                <span class="keyword">if</span>(multiple)&#123;</span><br><span class="line">                    <span class="comment">//批量操作</span></span><br><span class="line">                    <span class="keyword">for</span>(Long _id:<span class="keyword">new</span> TreeSet&lt;&gt;(tags.headSet(deliveryTag+<span class="number">1</span>)))&#123;</span><br><span class="line">                        tags.remove(_id);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//单个确认</span></span><br><span class="line">                    tags.remove(deliveryTag);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"未处理的消息: "</span>+tags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * deliveryTag 消息id</span></span><br><span class="line"><span class="comment">             * multiple 是否批量</span></span><br><span class="line"><span class="comment">             *      如果是true，就意味着，小于等于deliveryTag的消息都处理失败了</span></span><br><span class="line"><span class="comment">             *      如果是false，只是失败了deliveryTag这一条消息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//消息发送失败或者落地失败</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"===========handleNack==========="</span>);</span><br><span class="line">                System.out.println(<span class="string">"deliveryTag: "</span>+deliveryTag);</span><br><span class="line">                System.out.println(<span class="string">"multiple: "</span>+multiple);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当Channel设置成confirm模式时，发布的每一条消息都会获得一个唯一的deliveryTag</span></span><br><span class="line"><span class="comment">         * deliveryTag在basicPublish执行的时候加1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Long id = send(channel,<span class="string">"你的外卖已经送达"</span>.getBytes());</span><br><span class="line">        tags.add(id);</span><br><span class="line">        <span class="comment">//channel.waitForConfirms();</span></span><br><span class="line"></span><br><span class="line">        id =send(channel,<span class="string">"你的外卖已经送达"</span>.getBytes());</span><br><span class="line">        tags.add(id);</span><br><span class="line">        <span class="comment">//channel.waitForConfirms();</span></span><br><span class="line"></span><br><span class="line">        id = send(channel,<span class="string">"呵呵，不接电话"</span>.getBytes());</span><br><span class="line">        tags.add(id);</span><br><span class="line">        <span class="comment">//channel.waitForConfirms();  </span></span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// channel.waitForConfirms():表示等待已经发送给broker的消息act或者nack之后才会继续执行。</span></span><br><span class="line"><span class="comment">// channel.waitForConfirmsOrDie():表示等待已经发送给broker的消息act或者nack之后才会继续执行，如果有任何一个消息触发了nack则抛出IOException。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">rabbitTemplate</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">    RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate(connectionFactory);</span><br><span class="line">    rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> RabbitTemplate.ConfirmCallback() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> correlationData 唯一标识，有了这个唯一标识，我们就知道可以确认（失败）哪一条消息了</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> ack</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> cause</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"=====消息进行消费了======"</span>);</span><br><span class="line">            <span class="keyword">if</span>(ack)&#123;</span><br><span class="line">                System.out.println(<span class="string">"消息id为: "</span>+correlationData+<span class="string">"的消息，已经被ack成功"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"消息id为: "</span>+correlationData+<span class="string">"的消息，消息nack，失败原因是："</span>+cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// public static void main(String[] args) throws Exception&#123;</span></span><br><span class="line"><span class="comment">//     AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(Application.class);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     RabbitTemplate rabbitTemplate = context.getBean(RabbitTemplate.class);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     Order order  = createOrder();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     saveOrder(order);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     ObjectMapper objectMapper = new ObjectMapper();</span></span><br><span class="line"><span class="comment">//     byte[] body = objectMapper.writeValueAsBytes(order);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     MessageProperties messageProperties = new MessageProperties();</span></span><br><span class="line"><span class="comment">//     messageProperties.setContentType("json");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     Message message = new Message(body,messageProperties);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     System.out.println("id: "+order.getOrderId());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     //指定correlationData的值</span></span><br><span class="line"><span class="comment">//     rabbitTemplate.send("zhihao.direct.exchange","zhihao.miao.order",message,new CorrelationData(order.getOrderId().toString()));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     TimeUnit.SECONDS.sleep(10);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     context.close();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入库操作</span></span><br><span class="line"><span class="comment">// id: 11bc9eb3-fbcb-4777-9596-b6f6db81cafc</span></span><br><span class="line"><span class="comment">// 十月 22, 2017 7:14:14 下午 org.springframework.amqp.rabbit.connection.CachingConnectionFactory createBareConnection</span></span><br><span class="line"><span class="comment">// 信息: Created new connection: connectionFactory#50ad3bc1:0/SimpleConnection@4efc180e [delegate=amqp://zhihao.miao@192.168.1.131:5672/, localPort= 61095]</span></span><br><span class="line"><span class="comment">// =====消息进行消费了======</span></span><br><span class="line"><span class="comment">// 消息id为: CorrelationData [id=11bc9eb3-fbcb-4777-9596-b6f6db81cafc]的消息，已经被ack成功</span></span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<p>生产者与broker之间的消息可靠性保证的基本思路就是</p>
<blockquote>
<p>当消息发送到broker的时候，会执行监听的回调函数，其中deliveryTag是消息id（在同一个channel中这个数值是递增的，而multiple表示是否批量确认消息。<br>在生产端要维护一个消息发送的表，消息发送的时候记录消息id，在消息成功落地broker磁盘并且进行回调确认（ack）的时候，根据本地消息表和回调确认的消息id进行对比，这样可以确保生产端的消息表中的没有进行回调确认（或者回调确认时网络问题）的消息进行补救式的重发，当然不可避免的就会在消息端可能会造成消息的重复消息。针对消费端重复消息，在消费端进行幂等处理。（丢消息和重复消息是不可避免的二个极端，比起丢消息，重复消息还有补救措施，而消息丢失就真的丢失了。</p>
</blockquote>
<p><strong>总结</strong><br>消费端的消息确认分为二个步骤，</p>
<p>在channel.basicConsume指定为手动确认。<br>具体根据业务逻辑来进行判断什么是ack什么时候nack（又分为要不要重新requeue）</p>
<p>做到消息不能丢失，我们就要实现可靠消息，做到这一点，我们要做到下面二点：</p>
<ol>
<li><p>持久化</p>
<ol>
<li>exchange要持久化</li>
<li>queue要持久化</li>
<li>message要持久化</li>
</ol>
</li>
<li><p>消息确认</p>
<ol>
<li>启动消费返回（@ReturnList注解，生产者就可以知道哪些消息没有发出去）</li>
<li>生产者和Server（broker）之间的消息确认。</li>
<li>消费者和Server（broker）之间的消息确认。</li>
</ol>
</li>
</ol>
<p><strong>总结</strong></p>
<ol>
<li>建议Alternate Exchange的类型是fanout，防止出现路由失败。</li>
<li>fanout exchange一般不需要指定Alternate Exchange属性。</li>
<li>如果一个Exchange指定了Alternate Exchange，那就意味着，当Exchange和Alternate Exchange都无法路由的时候，才会触发return method。</li>
</ol>
<p>RabbitMQ允许您为消息和队列设置TTL（生存时间）。 可以使用可选的队列参数或策略完成（推荐使用后一个选项）。 可以为单个队列，一组队列或单个消息应用消息TTL。</p>
<p>总结：</p>
<ul>
<li>创建优先级队列，需要增加x-max-priority参数，指定一个数字。表示最大的优先级，建议优先级设置为1～10之间。</li>
<li>发送消息的时候，需要设置priority属性，最好不要超过上面指定的最大的优先级。</li>
<li>如果生产端发送很慢，消费者消息很快，则有可能不会严格的按照优先级来进行消费。</li>
<li>第一，如果发送的消息的优先级属性小于设置的队列属性x-max-priority值，则按优先级的高低进行消费，数字越高则优先级越高。</li>
<li>第二，如果发送的消息的优先级属性都大于设置的队列属性x-max-priority值，则设置的优先级失效，按照入队列的顺序进行消费。</li>
<li>第三，如果消费端一直进行监听，而发送端一条条的发送消息，优先级属性也会失效。</li>
</ul>
<p>RabbitMQ不能保证消息的严格的顺序消费。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/kpkym/2019/09/14/总结/RabbitMQ 总结/" data-id="ckkdeehbq000sp5jz9t2ibjbx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/总结/">总结</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/12/01/总结/docker 总结/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Docker 总结</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Head-First-Servlets-and-JSP/">Head First Servlets and JSP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/中间件/">中间件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/正则表达式/">正则表达式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/总结/">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/总结/" style="font-size: 20px;">总结</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/设计模式/" style="font-size: 20px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/09/14/总结/RabbitMQ 总结/">RabbitMQ 总结</a>
          </li>
        
          <li>
            <a href="/2018/12/01/总结/docker 总结/">Docker 总结</a>
          </li>
        
          <li>
            <a href="/2018/03/31/计算机网络/6 第六章 应用层/">应用层</a>
          </li>
        
          <li>
            <a href="/2018/03/25/总结/Redis 总结/">Redis 总结</a>
          </li>
        
          <li>
            <a href="/2018/03/17/计算机网络/5 第五章 运输层/">运输层</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 kpkym<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>